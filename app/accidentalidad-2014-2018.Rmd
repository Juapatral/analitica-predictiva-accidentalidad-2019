---
title: <b><center>Análisis y pronóstico de la información accidentalidad vehicular en el municipio de Medellín para los años 2014 a 2018</center></b>

author: <center>Lina María Grajales Vanegas <br> Juan Camilo Agudelo Marín <br> Jhon Anderson Lonoño Herrera <br> Juan Pablo Trujillo Alviz <br><br> Estudiantes del Posgrado en Analítica <br> Universidad Nacional de Colombia, Medellín</center>

date: "11 de agosto de 2019"

output:
  html_document:
    #toc: true
    #toc_depth: 5
    #toc_float: 
    #  collapsed: true
    #  smooth_scroll: true
    #toc_width: 5
    theme: cerulean
    highlight: default
    df_print: paged
    fig_width: 9
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## **Tabla de contenido**
 
1. [Introducción](#introduccion)

    1.1. [Motivación](#motivacion)
    
    1.2. [Metodología](#metodologia)

2. [Desarrollo](#desarrollo)

    2.1. [Identificación del problema](#identificacion-del-problema)
    
    2.2. [Identificación de los datos](#identificacion-de-los-datos)
    
    2.3. [Descripción de los datos](#descripcion-del-conjunto-de-datos)<br>
    
    2.3.1. [Limpieza y resumen](#limpieza-y-resumen-de-los-datos)<br>
    2.3.2. [Análisis de los datos](#analisis)<br>
    2.3.3. [Tratamiento de datos atípicos](#datos-atipicos-o-nulos)<br>
        
    2.4. [Modelación de los datos](#modelacion-de-los-datos)
    
    2.5. [Evaluación del modelo](#evaluacion-del-modelo)
    
    2.6. [Implementación del modelo](#implementacion)
    
3. [Conclusiones](#conclusiones)

4. [Bibliografía](#bibliografia)


## **1. Introducción**

Cada día se generan cantidades enormes de datos que reposan en los sistemas de información y bases de datos públicas o privadas. Es de interés para los analístas de datos obtener la mayor cantidad de información valiosa y confiable de estos datos, generando valor agregado a las entidades y así incidir en la toma de decisiones para mejorar los procesos internos y, por ende, los resultados económicos y sociales de la entidad. (**FALTA UNA REFERENCIA**)

Por esta razón, los estudiantes de la materia Analítica Predictiva del Posgrado de Analítica de la Universidad Nacional de Colombia tienen como objetivo identificar y dar solución a un problema utilizando las técnicas estadísticas y de ciencia de datos que consideren óptimas. 

### **1.1. Motivación**

La materia de Analítica Predictiva en el Posgrado de Analítica de la Universidad Nacional de Colombia enseña algunas técnicas estadísticas para el pronóstico y clasificación de datos, utilizando los conceptos de la estadística descriptiva y probabilística como cálculo de probabilidades, Teorema de Bayes, medidas de tendencia, funciones de distribuciones de probabilidad, pruebas de hipótesis, entre otros. Algunos de los modelos vistos en clase fueron:

* K vecinos cercanos (k-nearest-neighbors)
* Regresión lineal (univariada y multivariada) 
* Regresión Ridge y Lasso (Casos de multicolinealidad de la regresión lineal)
* Regresión logística (logit)
* Árboles de decisión y regresión (Decision Tree)
* Bosques aleatorios (Random Forest)
* K medias (K-means)
* Agrupamiento jerárquico (cluster)
* Máquinas de soporte vectorial (SVM)
* Redes neuronales (Neural Network)
* Validación cruzada (Cross validation)


El objetivo de este trabajo es entrenar un modelo predictivo que permita encontrar solución a un problema propuesto por los estudiantes. Este problema deberá contar con suficiente información para estimar el modelo y este no debe estar sobreentrenado. 

Los entregables del trabajo son:

1. Código de ejecución del modelo. (disponible [aquí](https://juapatral.github.io/analitica-predictiva-accidentalidad-2019/app/accidentalidad-2014-2018.Rmd))
2. Reporte que contenga el entendimiento desarrollado en el trabajo, bibliografía de soporte y la metodología seguida debidamente justificada. (disponible [aquí](https://juapatral.github.io/analitica-predictiva-accidentalidad-2019/app/accidentalidad-2014-2018.html))
3. Aplicativo web que permita visualizar los datos y la predicción del modelo. (disponible [aquí](https://google.com.co)).
4. Video promocional del aplicativo web, explicando su funcionalidad. (disponible [aquí](https://youtube.com)) 

### **1.2. Metodología**

Se propone utilizar la metodología [CRISP-DM](https://jdvelasq.github.io/ruta-n-predictiva/_downloads/5731da83c31e211e9b774ae8713246ed/CRISP-DM.pdf) en la que se sigue un flujo de trabajo para la identificación del problema y la propuesta, evaluación e implementación de la solución. Los pasos de la metodología *CRISP-DM* son los siguientes:

1. Identificación del problema del negocio.

2. Identificación del problema de datos.

3. Preparación y análisis de los datos.

4. Modelación.

5. Evaluación de los modelos y elección.

6. Implementación.

[Regresar](#tabla-de-contenido)

## **2. Desarrollo**

### **2.1. Identificación del problema**

La accidentalidad vial en las ciudades se ha ido posicionando año tras año como uno de los problemas que más costos sociales y económicos genera hasta llegar a denominarse como “pandemia”. Medellín no ha sido la excepción y en la actualidad buena parte de las políticas públicas se movilizan para mitigar este fenómeno.
Se estima que anualmente los costos totales por accidentalidad solo para Medellín son cerca de $ 1,8 billones, así que este es un problema cuya minimización puede dejar muchas ganancias.

Una herramienta importante y base para la toma de decisiones es una estimación precisa que explique el problema y que permita predecir cuándo y dónde puede suceder determinado tipo de accidente.   

Esta estimación es útil para diferentes actores. Los hacedores de política podrán determinar cuáles zonas son susceptibles de reestructuración de la malla vial, dónde deben enfocar los esfuerzos de capacitación o en cuáles lugares deben disponer de más servidores para la prevención y atención de los accidentes. Para el público en general le resultará de interés para tomar decisiones de movilidad, cuándo transitar y en qué; o en decisiones de vivienda, que sectores se deben evitar cuando se tienen hijos, por ejemplo.

En este trabajo se pretende responder a estas preguntas y brindarle a la ciudad la posibilidad de visibilizar la información de los accidentes vehiculares, sus riesgos asociados y con ello mitigarlos, a través de una única plataforma pública donde se realice un pronóstico del total de accidentes por tipo de accidente para el año 2019.

[Regresar](#tabla-de-contenido)

### **2.2. Identificación de los datos**

Para este trabajo se decidió utilizar la información de la accidentalidad vehicular en el municipio de Medellín para los años 2014 a 2018, disponibles al público en general en [este enlace.](https://geomedellin-m-medellin.opendata.arcgis.com/datasets/accidentalidad-georreferenciada-2018)

El conjunto de datos se compone de los accidentes de tránsito registrados por la Secretaría de Movilidad de la Alcaldía de Medellín, entre los años especificados. Se entiende por accidente de tránsito: "evento, generalmente involuntario, generado al menos por un  un vehículo en movimiento, que causa daños a personas y bienes involucrados en él, e igualmente afecta la normal circulación de los vehículos que se movilizan por la vía o vías comprendidas en el lugar o dentro de la zona de influencia del hecho". (Ley 769 de 2002 - Código Nacional de Tránsito)

La estructura de la tabla es la siguiente:

**Campo**|**Descripción**|**Tipo**|**Observación**
:--|--------|:-:|--------
OBJECTID|Identificación del registro (fila)|integer|Sin
X|Coordenada X (longitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
Y|Coordenada Y (latitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
RADICADO|Identificación única del accidente ante la Secretaría de Movilidad|string|Sin
HORA|Hora aproximada de la ocurrencia del accidente|datetime|Sin
DIA_NOMBRE|Nombre del día de la semana de la ocurrencia del accidente|string|Sin
PERIODO|Año de la ocurrencia del accidente|integer|Sin
CLASE|Tipo de accidente|string|Opciones entre: Atropello, caída del ocupante, choque, incendio, volcamiento y otro.
DIRECCION|Dirección descriptiva de la ubicación de la ocurrencia del accidente|string|Sin
DIRECCION_ENC|Dirección encasillada de la ubicación de la ocurrencia del accidente|string|Formato único de direcciones en el sistema de información de la Alcaldía de Medellín
CBML|Identificación única del lote más cercano a la ubicación de la ocurrencia del accidente|string|Acrónimo de comuna, barrio, manzana, lote
TIPO_GEOCOD|Tipo de ubicación según información catastral|string|Más información en el geocodificador de la Alcaldía disponible [aquí](https://www.medellin.gov.co/geomedellin/index.hyg#openModal)
GRAVEDAD|Gravedad del accidente|string|Opciones entre: Herido, muerto y solo daños
BARRIO|Barrio de la ubicación de la ocurrencia del accidente|string|Sin
COMUNA|Comuna de la ubicación de la ocurrencia del accidente|string|Sin
DISENO|Tipo de entramado de la ubicación de la ocurrencia del accidente|string|Opciones entre: ciclo ruta, glorieta. intersección, lote o predio, paso a nivel, paso elevado, paso inferior, pontón, puente, tramo vía, túnel o vía peatonal
MES|Número del mes de la ocurrencia del accidente|integer|Sin
DIA|Día del mes de la ocurrencia del accidente|integer|Sin
FECHA|Fecha de la ocurrencia del accidente|string|Formato [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
MES_NOMBRE|Nombre del mes de la ocurrencia del accidente|integer|Columna vacía

*Nota:* las coordenadas *Magna Medellín* corresponden a una transformación de las coordenadas elípticas internacionales [`wgs84`](https://en.wikipedia.org/wiki/World_Geodetic_System) a coordenadas planas propias establecidas por el Instituto Geográfico Agustín Codazzi (IGAC) en concordancia con el Subsecretaría de Catastro del municipio de Medellín. 

[Regresar](#tabla-de-contenido)

### **2.3. Descripción del conjunto de datos**

Para el análisis de la información se utilizará el dialecto *Tidyverse*, los paquetes *data.table*, *plotly*, *rmarkdown*, *shiny* y *leaflet* para lectura y visualización de los datos y *stats*, *rpart* y *rpart.plot* para estimar los modelos.

#### **2.3.1. Limpieza y resumen de los datos**
```{r Paquetes, message=FALSE, warning=FALSE}
# se instalan los paquetes necesarios

#install.packages("tidyverse")    # dialecto de ciencia de datos
#install.packages("data.table")   # manejo de tablas
#install.packages("ggplot2")      # manejo de graficas
#install.packages("plotly")       # graficas semi-dinamicas
#install.packages("grid")         # manejo de subgraficas
#install.packages("rmarkdown")    # utilizar rmarkdown
#install.packages("shiny")        # tableros de control dinamicos
#install.packages("prettydoc")    # dar formato a rmarkdown
#install.packages("sf")           # manejo de archivos espaciales (.shp)
#install.packages("leaflet")      # mapas dinamicos en HTML
#install.packages("rpart")        # arboles de decisiones
#install.packages("rpart.plot")   # graficar arboles

# cargar librerias
library(data.table)   # manejo de tablas
library(purrr)        # optimizacion de bucles
library(dplyr)        # manejo de tablas
library(plotly)       # graficos en html
library(tidyr)        # limpieza de datos
library(stringr)      # limpieza de texto
library(lubridate)    # limpieza de fechas
library(sf)           # manejo de archivos espaciales
```


De manera inicial se leen los archivos.

**Nota al ejecutador de código:** para algunos sistemas operativos o versiones de paquetes la limpieza no funciona correctamente, por lo que se recomienda volver a cargar el archivo a partir [aquí.](#nueva-lectura)

```{r lectura_consolidado, message=FALSE, warning=FALSE}
# lista archivos
lista <- list.files(pattern = "^Acc.*.csv", include.dirs = T, recursive = T)

# leer todos los archivos
lista_df <- map(lista, fread, sep = ",", encoding = "UTF-8", colClasses = "c")

# agregar archivos del 2014 a 2018
acc <- bind_rows(lista_df)

# ver cabecera del archivo
head(acc)
```

Se identifica que se deben hacer las siguientes correcciones en la tabla *acc*:

* Organizar la columna *FECHA* en formato [ISO 8601.](https://en.wikipedia.org/wiki/ISO_8601).

* Debido a la naturaleza del trabajo, se eliminan los nulos de la columna *CLASE* y se unifican los tipos de accidente, limpiando tildes y convirtiendo en mayúscula.

* De forma similar, se eliminan los nulos de la columna *DISENO*, se unifican los tipos de diseño, se limpian tildes y se convierte a mayúscula.

* Se eliminan las tildes de los días de la semana en la columna *DIA_NOMBRE*.

* Se crea la columna *COMUNA_BARRIO* a partir de la columna *CBML* con el objetivo de que sirva como clave foránea para la unión con el archivo espacial de barrios, disponible [aquí.](https://geomedellin-m-medellin.opendata.arcgis.com/datasets/limite-barrio-vereda-catastral) 
```{r primera_limpieza_acc, message=FALSE, warning=FALSE}
# organizar fecha
acc$FECHA <- ymd(gsub(pattern = "T.*", replacement = "", acc$FECHA),
                  "%Y-%M-%D")[1:209426]

# eliminar datos nulos y corregir clase
acc <- acc[-which(acc$CLASE == ""),]
acc$CLASE <- iconv(acc$CLASE, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$CLASE <- gsub("DE ", "", toupper(acc$CLASE))

# eliminar datos nulos y corregir disenio
acc <- acc[-which(acc$DISENO == ""),]
acc$DISENO <- iconv(acc$DISENO, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$DISENO <- gsub("DE ", "", toupper(acc$DISENO))

# corregir tildes de DIA_NOMBRE
acc$DIA_NOMBRE <- iconv(acc$DIA_NOMBRE, from = "UTF-8", to = "ASCII//TRANSLIT")

# crear columna de comuna_barrio
acc <- mutate(acc, COMUNA_BARRIO = str_sub(CBML, 1, 4))

# visualizar nueva acc
head(acc)
```

Se procede a cargar el archivo espacial de barrios para identificar correctamente el barrio y la comuna de la ubicación del accidente. Luego, se realiza una nueva limpieza de la tabla *acc*:

* Se limpian las tildes de la columna barrio y se convierte a mayúscula.

* Se eliminan los registros duplicados generados por la unión. 

* Se eliminan algunas columnas no necesarias para el análisis.

* Se renombran las columnas de *NOMBRE_BAR* y *NOMBRE_COM* por *BARRIO* y *COMUNA* respectivamente.
```{r union_espacial, message=FALSE, warning=FALSE}
# cargar archivo shp de barrios de medellin
barrio <- read_sf("files/Limite_Barrio_Vereda_Catastral/Limite_Barrio_Vereda_Catastral.shp")

# unir columnas de nombre barrio y comuna
acc <- inner_join(acc, 
                  select(barrio, CODIGO, NOMBRE_COM, NOMBRE_BAR),
                  by = c("COMUNA_BARRIO" = "CODIGO"))
  
# limpiar nombre de barrios
acc$NOMBRE_BAR <- iconv(acc$NOMBRE_BAR, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$NOMBRE_BAR <- toupper(acc$NOMBRE_BAR)

# eliminar posibles duplicados por errores de union
acc <- data.table:::unique.data.table(acc, by = "RADICADO")

# eliminar columnas
acc <- select(acc, -BARRIO, -COMUNA, -OBJECTID, -RADICADO, -DIRECCION_ENC,
              -DIRECCION, -HORA, -CBML, -TIPO_GEOCOD, -MES_NOMBRE, -geometry)

# renombrar
names(acc)[12:13] <- c("COMUNA","BARRIO")

# visualizar acc
head(acc)
```

Se realiza la lectura de la tabla de días especiales, se limpia y se realiza unión con la tabla de accidentes. Además, se cambia las columnas tal que si es un día especial tenga la marcación *Si*, de lo contrario será *No*.
```{r dias_especiales, message=FALSE, warning=FALSE}
# lectura del archivo
festivos <- fread("files/festivos_y_especiales.csv", header = T)

# convertir a si o no
festivos[,names(festivos)[-1]] <- festivos %>%
                                  transmute_at(c(names(festivos)[-1]),
                                               funs(ifelse(. == "X",
                                                           "Si", 
                                                           ifelse(. == "",
                                                                  "No",
                                                                  .)
                                                           )
                                                    )
                                               )

# convetir a formato fecha
festivos$FECHA <- ymd(festivos$FECHA)[1:172]

# visualizar festivos
head(festivos)
```

Se realiza la unión de las tablas y se convierten los datos de los días especiales a *No* en caso de que no haya encontrado coincidencia en la unión.
```{r union_dias_especiales, message=FALSE, warning=FALSE}
# union de tablas
acc <- merge(x = acc, y = festivos, by = "FECHA", all.x = T)

# transformar variables
acc[,names(festivos)[-1]] <- acc %>%
                             transmute_at(c(names(festivos)[-1]),
                                         funs(ifelse(is.na(.),
                                                     "No",
                                                     .)
                                              )
                                         )

# visualizar acc
head(acc)
```

Se realiza la conversión a la codificación [*UTF-8*](https://en.wikipedia.org/wiki/UTF-8) y se guarda el nuevo archivo.
```{r conversion-guardado, message=FALSE, warning=FALSE}
# convertir a utf8
acc[,2:length(acc)] <- map(.x = acc[,2:length(acc)], .f = enc2utf8)

 # guardar archivo
fwrite(acc, "files/accidentalidad_georreferenciada_completa.csv", sep = ",")

# eliminar archivo y limpiar memoria
rm(acc)
gc(reset = T)
```

##### Nueva lectura
**Nota:** para algunos sistemas operativos o versiones de paquetes la limpieza no funciona correctamente, por lo que se recomienda volver a cargar el archivo a partir de este punto y no ejecutar el código anterior. 

```{r cargar-archivo, message=FALSE, warning=FALSE}
# volver a cargar el archivo
acc <- fread("files/accidentalidad_georreferenciada_completa.csv",
             sep = ",",
             encoding = "UTF-8")

# organizar fecha
acc$FECHA <- ymd(acc$FECHA)

# visualizar
head(acc)
```

Como se observa, la estructura de la tabla resultante es la siguiente:

**Campo**|**Descripción**|**Tipo**|**Observación**
:--|--------|:-:|--------
FECHA|Fecha de la ocurrencia del accidente|datetime|Formato [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
X|Coordenada X (longitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
Y|Coordenada Y (latitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
DIA_NOMBRE|Nombre del día de la semana de la ocurrencia del accidente|string|Sin
PERIODO|Año de la ocurrencia del accidente|integer|Sin
CLASE|Tipo de accidente|string|Opciones entre: Atropello, caída del ocupante, choque, incendio, volcamiento y otro.
GRAVEDAD|Gravedad del accidente|string|Opciones entre: Herido, muerto y solo daños
DISENO|Tipo de entramado de la ubicación de la ocurrencia del accidente|string|Opciones entre: ciclo ruta, glorieta. intersección, lote o predio, paso a nivel, paso elevado, paso inferior, pontón, puente, tramo vía, túnel o vía peatonal
MES|Número del mes de la ocurrencia del accidente|integer|Sin
DIA|Día del mes de la ocurrencia del accidente|integer|Sin
COMUNA_BARRIO|Identificador de la comuna y el barrio en el sistema de información de la Alcaldía|string|Sin
BARRIO|Barrio de la ubicación de la ocurrencia del accidente|string|Sin
COMUNA|Comuna de la ubicación de la ocurrencia del accidente|string|Sin
FESTIVO|Indicador de si el día es festivo o no|boolean|Opciones: Si o No
MADRE|Indicador de si el día es día de la madre o no|boolean|Opciones: Si o No
NAVIDAD|Indicador de si el día pertenece a las festividades de navidad o no|boolean|Opciones: Si o No
BRUJITOS|Indicador de si el día es el 31 de octubre o no|boolean|Opciones: Si o No
SEMSANTA|Indicador de si el día pertenece a la Semana Santa o no|boolean|Opciones: Si o No
ESCOLAR|Indicador de si el día pertenece a la época de vacaciones escolares o no|boolean|Opciones: Si o No

#### **2.3.2. Análisis**

Realizaremos un análisis descriptivo para buscar identificar las variables asociadas a la accidentalidad vial en la ciudad de Medellín a través del análisis y la interpretación de las cifras de accidentes registrados en la Secretaría de Movilidad.

##### Accidentalidad por día, mes y año
La siguiente gráfica muestra el registro de accidentes por día, mes y año

```{r}
#Para realizar la un gráfico con subgráficos creamos la función multiplots así:
library(ggplot2)
library(grid)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

```{r}
acc_nombredia <- acc %>% 
              group_by(DIA_NOMBRE) %>% 
              summarize(total_registros = n())
acc_nombredia$DIA_NOMBRE<-ordered(acc_nombredia$DIA_NOMBRE,levels=c( "LUNES", "MARTES", "MIERCOLES", "JUEVES", "VIERNES", "SABADO","DOMINGO"))
# Gráfico día
p2 <- ggplot(data=acc_nombredia, aes(x=DIA_NOMBRE, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = 
    .8)+
    xlab("Días")+ # eje x
    ylab("Total registros")+ # eje y
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))+ # Girar label eje x
    ggtitle("Número de accidentes por días de la semana") #título del gráfico
#Gráfico mes
acc_mes <- acc %>% 
              group_by(MES) %>% 
              summarize(total_registros = n())
p1 <- ggplot(data=acc_mes, aes(x=MES, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = 
    .8)+
    xlab("Mes")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por mes") #título del gráfico
#Gráfico año
acc_ano <- acc %>% 
              group_by(PERIODO) %>% 
              summarize(total_registros = n())
p3 <- ggplot(data=acc_ano, aes(x=PERIODO, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = 
    .8)+
    xlab("Año")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por año") #título del gráfico

multiplot(p1, p2, p3, cols=2)

```
En está gráfica podemos observar que la mayor accidentalidad se presenta los días viernes, durante el mes de gasto también hay un mayor número de accidentes y en el 2016 fue el año con más accidentes durante el periodo de análisi 2014-2018, mientras que los días domingo, el mes de enero y en el año 2018 se registra una accidentalidad menor.

##### Accidentalidad por comuna y tipo de vía
```{r}

# Accidentes por comuna
acc_comuna <- acc %>% 
              group_by(COMUNA) %>% 
              summarize(total_registros = n())
p4 <- ggplot(data=acc_comuna, aes(x=COMUNA, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = .8)+
    xlab("Comuna")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Comuna")+ #título del gráfico
    coord_flip()

# accidente por diseño de via
acc_diseno <- acc %>% 
              group_by(DISENO) %>% 
              summarize(total_registros = n())
p5 <- ggplot(data=acc_diseno, aes(x=DISENO, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = 
    .8)+
    xlab("Diseño de la vía")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Tipo de vía")+ #título del gráfico
    coord_flip()
multiplot(p4, p5, cols = 2)
```

El mayor número de accidentes ocurre en La candelaria, seguido por Laureles y Castilla.
Los tramos en la vía es donde se presentan la mayor parte de los accidentes seguidos por las intersecciones.

##### Accidentalidad por tipo de accidente
```{r}
acc_clase <- acc %>% 
              group_by(CLASE) %>% 
              summarize(total_registros = n())
p6 <- ggplot(data=acc_clase, aes(x=CLASE, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = 
    .8)+
    xlab("Tipo de accidente")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por tipo de accidente") #título del gráfico
p6
```

Notamos que la principal causa de los accidentes viales es debido a choques y son pocos los accidentes donde se  termina con volcamiento de los vehículos.

##### Accidentalidad por gravedad de
```{r}
acc_gravedad <- acc %>% 
              group_by(GRAVEDAD) %>% 
              summarize(total_registros = n())
p7 <- ggplot(data=acc_gravedad, aes(x=GRAVEDAD, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "dodgerblue3", color = "grey48", alpha = 
    .8)+
    xlab("Gravedad del accidente")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por gravedad del accidente") #título del gráfico
p7
```

Desde el 2014 hasta el 2018 se tuvieron un número mayor de heridos que de daños.


##### **Ahora analizaremos las variables agrupadas por la clase de accidente.**

##### Gráfico de gravedad de acuerdo al tipo de accidente
```{r}
acc_group_clase<- acc %>% group_by(CLASE, GRAVEDAD) %>% summarize(conteo = n())

ggplot(data=acc_group_clase, aes(x=CLASE, y=conteo, fill=GRAVEDAD)) + 
    geom_bar(stat="identity", position="dodge")+
    coord_flip()
```
De acuerdo al tipo de accidente, vemos que los choques generan una mayor cantidad de daños y la mayor cantidad de heridos.

##### Clasificación de los tipos de accidentes por meses.
```{r}
acc_group_mes<- acc %>% group_by(MES,CLASE) %>% summarize(conteo = n()) 
ggplot(data=acc_group_mes, aes(x=CLASE, y=conteo, fill=MES)) + 
    geom_bar(stat="identity", position="dodge")
```
La mayor cantidad de choques se presenta en agosto.

##### Agrupación de tipo de accidente por año
```{r}
acc_group_year<- acc %>% group_by(CLASE, PERIODO) %>% summarize(conteo = n()) 
acc_group_year$PERIODO<- as.factor(acc_group_year$PERIODO)
ggplot(data=acc_group_year, aes(x=CLASE, y=conteo, fill=PERIODO)) + 
    geom_bar(stat="identity", position="dodge")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))+
    scale_fill_manual(values=c("#d0d1e6", "#bdc9e1","#74a9cf","#2b8cbe","#045a8d"))

```

##### Agrupación de tipo de accidente por día de la semana.
```{r}
acc_group_dia<- acc %>% group_by(CLASE, DIA_NOMBRE) %>% summarize(conteo = n()) 

ggplot(data=acc_group_dia, aes(x=CLASE, y=conteo, fill=DIA_NOMBRE)) + 
    geom_bar(stat="identity", position="dodge")+
    scale_fill_manual(values=c("#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"))+
  coord_flip()
```

##### Tipo de accidente ocurrido en los días festivos.
```{r}
acc_group_festivo<- acc %>% group_by(CLASE, FESTIVO) %>% summarize(conteo = n()) 

ggplot(data=acc_group_festivo, aes(x=CLASE, y=conteo, fill=FESTIVO)) + 
    geom_bar(stat="identity", position="dodge")
```
Se observa que los accidentes ocurridos se presentan en los días ordinarios y que la accidentalidad en los días festivos es baja.

#### Series temporales 
Para guiar el análisis de la información resulta útil representar gráficamente los datos o una muestra de los mismos. En este caso, como la variable a predecir es el número de accidentes viales registrados diariamente en la secretaría de movilidad y esta variable depende del tiempo, se desea representarla como una serie temporal.

##### Serie temporal de accidentalidad por día
```{r}
acc_fecha <- acc %>% 
              group_by(FECHA) %>% 
              summarize(total_registros = n())

plot_ly (data=subset(acc_fecha,subset = (FECHA<="2018-12-31")),
         x = ~FECHA,
         y = ~total_registros,
         type = "scatter" ,mode = "lines",
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
         layout(title='Registros de accidentalidad',
         xaxis=list(title="Día"),
         yaxis=list(title="Total registros"))

```

##### Serie temporal de accidentalidad por año
```{r}
acc_fecha$year<-format(acc_fecha$FECHA,"%Y")
plot_ly (data=subset(acc_fecha,subset = (FECHA<="2018-12-31")),
         x = ~FECHA,
         y = ~total_registros,
         type = "scatter" ,mode = "lines",
         split = ~year,
         line=list(width=1))%>%
  layout(title='Registros de accidentalidad',
         xaxis=list(title="Día"),
         yaxis=list(title="Total registros"))
```
   
##### Usando la función aggregate obtenemos el promedio diario para cada año de registros de accidentes:
```{r}
aggregate(total_registros~year,data=acc_fecha,FUN=mean)
```

##### Ahora obtenemos el promedio diario para cada mes y cada año: 
```{r}
acc_fecha$Fecha<-as.Date(acc_fecha$FECHA,"%d/%m/%Y")
acc_fecha$mes<-format(acc_fecha$Fecha,"%m")
acc_fecha$mes<-strftime(acc_fecha$Fecha, format = "%B")
acc_fecha$mes<-ordered(acc_fecha$mes,levels=c( "enero", "febrero", "marzo", 
"abril", "mayo", "junio","julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"))
aggregate(total_registros~year*mes,data=acc_fecha,FUN=mean)%>%
  plot_ly(x = ~mes,
         y = ~total_registros,
         type = "scatter" ,mode = "lines",
         split = ~year,
         line=list(width=1))%>%
  layout(title='Promedio diario mensual de accidentes registrados',
         xaxis=list(title="Día"),
         yaxis=list(title="Total registros"))
```

##### Ahora utilicemos el diagrama de caja y bigotes para explorar relaciones:

#### Diagrama de caja y bigotes de número de accidentes por año:
```{r}
plot_ly (data=subset(acc_fecha,subset = (Fecha<="2018-12-31")),
         x = ~year,
         y = ~total_registros,
         type = "box")%>%
  layout(title='Registros de accidentes',
         xaxis=list(title="Año"),
         yaxis=list(title="Total registros"))
```



##### Diagrama de caja y bigotes para cada mes:
```{r}
acc_fecha$diames<-format(acc_fecha$Fecha,"%d")
plot_ly (data=subset(acc_fecha,subset = (Fecha<="2018-12-31")),
         x = ~mes,
         y = ~total_registros,
         type = "box")%>%
  layout(title='Registros de accidentes',
         xaxis=list(title="Mes"),
         yaxis=list(title="Total registros"))
```

##### Diagrama de caja y bigotes para cada día de la semana:
```{r}
acc_fecha$dia_semana<-weekdays(acc_fecha$Fecha)
acc_fecha$dia_semana<-ordered(acc_fecha$dia_semana,levels=c( "lunes", "martes", "miércoles", "jueves", "viernes", "sábado","domingo"))
plot_ly (data=subset(acc_fecha,subset = (Fecha<="2018-12-31")),
         x = ~dia_semana,
         y = ~total_registros,
         type = "box")%>%
  layout(title='Registros de accidentes',
         xaxis=list(title="Mes"),
         yaxis=list(title="Total registros"))
```

[Regresar](#tabla-de-contenido)

#### **2.3.3. Datos atípicos o nulos**

El manejo de datos nulos se dio en la [sección 2.3.1.](#limpieza-y-resumen-de-los-datos) donde se tomaron las siguientes decisiones:

* Si *CLASE* era nulo, se eliminaba por la naturaleza del objetivo.
* Si *DISENO* era nulo, se eliminaba por la naturaleza del objetivo.
* Si *COMUNA_BARRIO* era nulo o no estaba en la tabla de barrios, se eliminaba ya que posiblemente corresponda a un dato difícil de medir.

Después de realizar el análisis, se concluye que ningún dato atípico será eliminado ya que corresponden a los datos de las tablas originales, a los cuales se les aplicaron transformaciones mínimas.  

[Regresar](#tabla-de-contenido)

### **2.4. Modelación de los datos**

Se escogen tres agrupamientos para verificar el modelo.
```{r}
acc_agrupado_0 <- acc%>%group_by(FECHA,CLASE,DISENO,DIA_NOMBRE,DIA,PERIODO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(FECHA)
acc_agrupado_0$DIA <- as.integer(acc_agrupado_0$DIA)
acc_agrupado_0$PERIODO <- as.integer(acc_agrupado_0$PERIODO)


acc_agrupado_1<-acc%>%group_by(FECHA,CLASE,DIA_NOMBRE,DIA,PERIODO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(FECHA)
acc_agrupado_1$DIA <- as.integer(acc_agrupado_1$DIA)
acc_agrupado_1$PERIODO <- as.integer(acc_agrupado_1$PERIODO)

acc_agrupado_2 <-acc%>%group_by(FECHA,DIA_NOMBRE,PERIODO,CLASE,MES,DIA,COMUNA,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(FECHA)
acc_agrupado_2$DIA <- as.integer(acc_agrupado_2$DIA)
acc_agrupado_2$PERIODO <- as.integer(acc_agrupado_2$PERIODO)
```

##### **Elección del modelo de regresión**

##### Modelo grupo 0
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_0<-lm(ACCIDENTES~FECHA+CLASE+DISENO+DIA_NOMBRE+PERIODO+FESTIVO+MADRE+NAVIDAD+BRUJITOS+SEMSANTA+ESCOLAR,data=acc_agrupado_0, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_0)
```

##### Modelo grupo 1
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+DIA+PERIODO+FESTIVO+MADRE+NAVIDAD+BRUJITOS+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```

Al verificar los valores P, se opta por retirar la variable *BRUJITOS*.
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+DIA+PERIODO+FESTIVO+MADRE+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```

No se observa nigun cambio en el R cuadrado ajustado. se opta por quitar *DIA*. 
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+MADRE+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```


No se observa nigun cambio en el R cuadrado ajustado. se opta por quitar *MADRE*. 
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```

No se observa nigun cambio en el R cuadrado ajustado. se opta por quitar 
*ESCOLAR*. 
```{r}
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```


Dado que al quitar la variable anterior el R cuadrado ajustado bajo 0.0001, por lo cual se opta por dejar el modelo con la variable *ESCOLAR*.
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```


##### Se evalúa el agrupado 2 para determinar si este tiene un mejor ajuste.
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_2<-lm(ACCIDENTES~FECHA+DIA_NOMBRE+PERIODO+CLASE+MES+DIA+COMUNA+FESTIVO+MADRE+NAVIDAD+BRUJITOS+SEMSANTA+ESCOLAR,data=acc_agrupado_2, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_2)
```


Agregando la variable de comunas, vemos que el modelo es menos significativo que e agrupado 1 por lo que se opta por hacer la validacion con el modelo del agrupado 1.


##### Calculo de $R^2$ Manual de la regresion para comprobar con el función 
```{r}
y0_tr<-mean(acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"])
r0_tr<-acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"]-y0_tr
R0_tr<-mean(r0_tr^2)
y_pred_tr_lm<-predict(modelo_lm_1)
r_tr_lm<-acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"]-y_pred_tr_lm
R_tr_lm<-mean(r_tr_lm^2)
R2_lm<-1-R_tr_lm/R0_tr

print(R2_lm)
```

este da igual.

#Modelo Poisson
```{r}
modelo_glm<-glm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO + 
    FESTIVO + NAVIDAD + SEMSANTA + ESCOLAR,data = acc_agrupado_1, 
    subset = (FECHA <= "2017-12-31"),family = "poisson")
summary(modelo_glm)
```
##### se procede a hacer un ajuste del modelo Poisson, para esto de calcula un Pseudo $R^2$
```{r}
# ERROR DE AQUI EN ADELANTE
y_pred_tr_glm<-predict(modelo_glm,type="response")
r_tr_glm<-acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"]-y_pred_tr_glm
R_tr_glm<-mean(r_tr_glm^2)
R2_tr_glm<-1-R_tr_glm/R0_tr
print(R2_tr_glm)
```

#Este modelo muestra un $R^2$ superior por lo cuál se usará para hacer las comparaciones de modelos.

## GRAFICA JHON
# Análisis de predichos versus observados
Creación de un dataframe para usar con plotly:
##### Se elabora un DataFrame para poder graficar predichos y observados de los modelos

```{r}
resultados_lm_glm<-data.frame(FECHA=  acc_agrupado_1$FECHA[acc_agrupado_1$FECHA<="2017-12-31"],ACCIDENTES=acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"],
                               pred_lm=y_pred_tr_lm,
                               pred_glm=y_pred_tr_glm,
                             res_lm=r_tr_lm,
                             res_glm=r_tr_glm)
```
# Predichos y observados:

```{r}
plot_ly (data=resultados_lm_glm,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter" ,mode = "lines",
         name='Real',
         line=list(width=1,color='rgb(205, 12, 24)')) %>%
  add_trace(y= ~pred_lm,
            name='Modelo lineal general',
            line=list(width=1,color='rgb(22, 96, 167)')) %>%
  add_trace(y= ~pred_glm,
            name='Modelo Poisson',
            line=list(width=1,color='rgb(255, 51, 0)')) %>%
  layout(title='Registros DE ACCIDENTES ',
         xaxis=list(title="Fecha"),
         yaxis=list(title="ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

#Comparacion de modelo lineal y observados
```{r}
plot_ly (data=resultados_lm_glm,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter" ,mode = "lines",
         name='Real',
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
  add_trace(y= ~pred_lm,
            name='Modelo lineal general',
            line=list(width=1,color='rgb(22, 96, 167)'))%>%
  layout(title='Registros de Accidentes',
         xaxis=list(title="Fecha"),
         yaxis=list(title="Accidentes"),
         legend = list(x = 0.75, y = 0.9))
```

#Comparacion de modelo Poisson y observados
```{r}
plot_ly (data=resultados_lm_glm,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter" ,mode = "lines",
         name='Real',
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
  add_trace(y= ~pred_glm,
            name='Modelo Ajustado Poisson',
            line=list(width=1,color='rgb(22, 96, 167)'))%>%
  layout(title='Registros de Accidentes',
         xaxis=list(title="Fecha"),
         yaxis=list(title="Accidentes"),
         legend = list(x = 0.75, y = 0.9))
```

#se puede observar que los modelos logran describir las observaciones sin observar ningun comportamiento extraño.

# HASTA ACÁ GRÁFICA JHON Y EMPIEZA LINA


# Predichos vs observados:

```{r}
plot_ly (data=resultados_lm_glm,
         x = ~ACCIDENTES,
         y = ~pred_lm,
         text = ~FECHA,
         type = "scatter" ,mode="markers",
         name='Modelo lineal general',
         marker=list(size=3,color='rgb(22, 96, 167)'))%>%
  add_trace(y= ~pred_glm,
            text = ~FECHA,
            name='Modelo lineal Poisson',
            marker=list(size=3,color='rgb(255, 51, 0)'))%>%
  add_trace(x=c(0:200),y=c(0:200),
            mode="lines",text=rep(NA,201),
            name="Identidad")%>%
  layout(title='Registros ACCIDENTALIDAD',
         xaxis=list(title="Observados"),
         yaxis=list(title="Predichos"),
         legend = list(x = 0.75, y = 0.9))
```

# Residuales vs observados:
```{r}
plot_ly (data=resultados_lm_glm,
         x = ~ACCIDENTES,
         y = ~res_lm,
         type = "scatter" ,mode="markers",
         name='Modelo lineal general',
         text = ~FECHA,
         marker=list(size=3,color='rgb(22, 96, 167)'))%>%
  add_trace(y= ~res_glm,
            name='Modelo Poisson',
            text = ~FECHA,
            marker=list(size=3,color='rgb(255, 51, 0)'))%>%
  layout(title='Registros ACCIDENTES',
         xaxis=list(title="Observados"),
         yaxis=list(title="Residuales"),
         legend = list(x = 0.75, y = 0.9))
```

# Predicción del 2018
Cálculo de las predicciones:
```{r}
datos_val<-subset(acc_agrupado_1,subset=(FECHA>="2018-01-01" & FECHA<="2018-12-31"))
y_pred_vl_lm<-predict(modelo_lm_1,newdata = datos_val)
y_pred_vl_glm<-predict(modelo_glm,type="response",newdata = datos_val)
r_vl_lm<-datos_val$ACCIDENTES-y_pred_vl_lm
r_vl_glm<-datos_val$ACCIDENTES-y_pred_vl_glm
r0_vl<-datos_val$ACCIDENTES-y0_tr
```

#Cálculo de los R2 de predicción:
```{r}
R_vl_lm<-mean(r_vl_lm^2)
R_vl_glm<-mean(r_vl_glm^2)
R0_vl<-mean(r0_vl^2)
R2_vl_lm<-1-R_vl_lm/R0_vl
R2_vl_glm<-1-R_vl_glm/R0_vl
print(R2_vl_lm)
```

```{r}
print(R2_vl_glm)
```

# Gráfico de los residuales en validación:
```{r}
resultados_lm_glm_val<-data.frame(FECHA=datos_val$FECHA,                            ACCIDENTES=datos_val$ACCIDENTES,
                              pred_lm=y_pred_vl_lm,
                              pred_glm=y_pred_vl_glm,
                              res_lm=r_vl_lm,
                              res_glm=r_vl_glm)
```

```{r}
plot_ly (data=resultados_lm_glm_val,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter" ,mode = "lines",
         name='Real',
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
  add_trace(y= ~pred_lm,
            name='Modelo lineal general',
            line=list(width=1,color='rgb(22, 96, 167)'))%>%
  add_trace(y= ~pred_glm,
            name='Modelo Poisson',
            line=list(width=1,color='rgb(255, 51, 0)'))%>%
  layout(title='Registros ACCIDENTES (Validación)',
         xaxis=list(title="FECHA"),
         yaxis=list(title="ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

##### Modelo Arboles Decision BASE 1
Entrenamiento del árbol
```{r}
library(rpart)
modelo_rpart<-rpart(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
```
# Visualización del resultado

```{r}
print(modelo_rpart)
```

Con la función rpart.plot():
```{r}
library(rpart.plot)
rpart.plot(modelo_rpart,tweak = 1.1)
```

Visualización de la importancia de las variables:
```{r}
summary(modelo_rpart)
```

# Cálculo de los $R^2$ de predicción y entrenamiento para el árbol:
```{r}
y_pred_tr_rpart<-predict(modelo_rpart)
y_pred_vl_rpart<-predict(modelo_rpart,newdata = datos_val)
r_tr_rpart<-acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"]-y_pred_tr_rpart
r_vl_rpart<-datos_val$ACCIDENTES-y_pred_vl_rpart
R_tr_rpart<-mean(r_tr_rpart^2)
R_vl_rpart<-mean(r_vl_rpart^2)
R2_tr_rpart<-1-R_tr_rpart/R0_tr
R2_vl_rpart<-1-R_vl_rpart/R0_vl
print(R2_tr_rpart)
```

```{r}
print(R2_vl_rpart)
```

# Comparación de todos los modelos
Comparación en el entrenamiento
```{r}
comparacion_tr<-data.frame(FECHA=acc_agrupado_1$FECHA[acc_agrupado_1$FECHA<="2017-12-31"],
                           ACCIDENTES=acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"],
                           glm=y_pred_tr_glm,
                           arbol=y_pred_tr_rpart)
```

# Gráfica de todas las series en entrenamiento:
```{r}
plot_ly (data=comparacion_tr,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter" ,mode = "lines",
         name='Real',
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
  add_trace(y= ~glm,
            name='Modelo Poisson',
            line=list(width=1,color='rgb(22, 96, 167)'))%>%
  add_trace(y= ~arbol,
            name='Árbol',
            line=list(width=1,color='rgb(255, 51, 0)'))%>%
  layout(title='Registros ACCIDENTES (Entrenamiento)',
         xaxis=list(title="FECHA"),
         yaxis=list(title="ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

# Comparación en la validación
```{r}
comparacion_vl<-data.frame(FECHA=datos_val$FECHA,
                           ACCIDENTES=datos_val$ACCIDENTES,
                           glm=y_pred_vl_glm,
                           arbol=y_pred_vl_rpart)
```

#Gráfica de todas las series en entrenamiento:
```{r}
plot_ly (data=comparacion_vl,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter" ,mode = "lines",
         name='Real',
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
  add_trace(y= ~glm,
            name='Modelo Poisson',
            line=list(width=1,color='rgb(22, 96, 167)'))%>%
  add_trace(y= ~arbol,
            name='Árbol',
            line=list(width=1,color='rgb(255, 51, 0)'))%>%
  layout(title='Registros ACCIDENTES (Validación)',
         xaxis=list(title="FECHA"),
         yaxis=list(title="ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```


#Comparación con los (pseudo) R2:

```{r}
Entrenamiento<-c(R2_lm,R2_tr_glm,R2_tr_rpart)
Validacion<-c(R2_vl_lm,R2_vl_glm,R2_vl_rpart)
MSE_acc <- c(R_vl_lm,R_vl_glm,R_vl_rpart)
nombres<-c("lm","glm","árbol")
ResultadosR2<-data.frame(Entrenamiento=Entrenamiento,Validacion=Validacion,MSE=MSE_acc)
rownames(ResultadosR2)<-nombres
ResultadosR2
```


[Regresar](#tabla-de-contenido)

### **2.5. Evaluación del modelo**

#el Modelo ajustado de Poisson es el que menor error cuadratico muestra:
```{r echo=FALSE, message=FALSE, warning=FALSE}
print(ResultadosR2[which(ResultadosR2$MSE==min(ResultadosR2$MSE)),3])
```

Por lo que a partir de estas evidencias lo escogemos como el modelo más conveniente para hacer la predicción.

[Regresar](#tabla-de-contenido)

### **2.6. Implementación**
#Se prepara el modelo para hacer la prediccion del año 2019, se importa el correspondiente archivo de entrada para ser la predicción.

```{r}
matriz_2019 <- fread("files/matriz-2019-pronostico.csv",sep = ";",colClasses = "character")
matriz_2019$FECHA <- as.Date(matriz_2019$FECHA)
matriz_2019$PERIODO <- as.numeric(matriz_2019$PERIODO)
```

#Se crea el nuevo vector de predicciones
```{r}
ACCIDENTES_PRED <- predict(modelo_glm, newdata = matriz_2019, type = "response")
```

se guarda junto el conjunto de datos nuevo para ser visualizado en la aplicación
```{r}
ACCIDENTES_PRED <- matriz_2019%>%mutate(ACCIDENTES= round(predict(modelo_glm, newdata = matriz_2019, type = "response"),0))

fwrite(ACCIDENTES_PRED,"files/matriz-2019-pronosticada.csv", sep = ";")
```


**FALTA**

[Regresar](#tabla-de-contenido)

## **3. Conclusiones**

**FALTA**

[Regresar](#tabla-de-contenido)

## **4. Bibliografía**

+ Friedman, J., Hastie, T., & Tibshirani, R. (2001). The elements of statistical learning (Vol. 1, No. 10). New York: Springer series in statistics.

+ Hothorn, T., & Everitt, B. S. (2014). A handbook of statistical analyses using R. Chapman and Hall/CRC.

+ James, G., Witten, D., Hastie, T., & Tibshirani, R. (2013). An introduction to statistical learning (Vol. 112, p. 18). New York: springer.

+ McCullagh, P. (2019). Generalized linear models. Routledge.

+ Montgomery, D. C., & Runger, G. C. (2007). Applied statistics and probability for engineers, (With CD). John Wiley & Sons.

**FALTA**

**R Markdown**

+ [Infografía de *Rmarkdown*](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)

+ [API de *Rmarkdown*](https://bookdown.org/yihui/rmarkdown/)

---

**Plotly**

+ [API de *Plotly*](https://plot.ly/r/reference/)

+ [API de *Plotly*, parte 2](https://plot.ly/r/reference/#Layout_and_layout_style_objects)

+ [Gráfico de área en *Plotly*](https://plot.ly/r/filled-area-plots/)

+ [Aplicar color a barra vertical en *Plotly*](https://stackoverflow.com/questions/33891362/r-shiny-background-of-sidebar-panel)

+ [Ajustar tamaño en *Plotly*](https://plot.ly/r/setting-graph-size/)

+ [Descripción emergente en *Plotly*](https://plot.ly/r/hover-text-and-formatting/)

---

**LeafLet y archivos espaciales**

+ [Introducción a los archivos espaciales en *R*](https://datacarpentry.org/r-raster-vector-geospatial/06-vector-open-shapefile-in-r/)

+ [Lectura de archivos espaciales usando *ST* en *R*](https://r-spatial.github.io/sf/reference/st_read.html)

+ [API de *LeafLet* en *R*](https://rstudio.github.io/leaflet/map_widget.html)

+ [Etiquetas y descripción emergente en *LeafLet* para *R*](https://stackoverflow.com/questions/48147282/how-to-add-labels-on-top-of-polygons-in-leaflet)

+ [Opciones de resaltar en *LeafLet* para *R*](https://stackoverflow.com/questions/46209309/r-leaflet-highlight-options)

---

**Shiny**

+ [API de *Shiny*](http://shiny.rstudio.com/articles/basics.html)

+ [Incrustar videos en *Shiny*](https://stackoverflow.com/questions/43740470/embed-instagram-youtube-into-shiny-r-app)

+ [Rango de fechas en *Shiny*](https://shiny.rstudio.com/gallery/date-and-date-range.html)

+ [Pestañas en *Shiny*](https://shiny.rstudio.com/articles/tabsets.html)

+ [Incrustar HTML y Markdown en *Shiny*](http://shiny.rstudio.com/gallery/including-html-text-and-markdown-files.html)

+ [Lista desplegable en Shiny](https://shiny.rstudio.com/reference/shiny/latest/selectInput.html)

+ [*Plotly* en *Shiny*](https://stackoverflow.com/questions/41255810/r-shinyapp-not-showing-plot-ly-in-browser-but-show-only-graph-in-viewer-pane)

+ [Barra deslizable y rango en *Shiny*](http://shiny.rstudio.com/gallery/slider-bar-and-slider-range.html)

+ [Embeber imágen en *Shiny*](https://stackoverflow.com/questions/21996887/embedding-image-in-shiny-app)

+ [Ajustar posición en *Shiny*](https://stackoverflow.com/questions/42913364/center-plotly-plot-in-r-shiny?rq=1)

+ [Fecha y rango de fechas en *Shiny*](https://shiny.rstudio.com/gallery/date-and-date-range.html)

+ [*LeafLet* en *Shiny*](https://spatialanalysis.github.io/workshop-notes/interactive-maps-with-shiny.html)

+ [Lista de pestañas en *Shiny*](https://shiny.rstudio.com/reference/shiny/1.0.2/navlistPanel.html)

---

**Demás**

+ [link aquí](https://wikipedia.com)

+ [Paleta de colores para mapas](http://colorbrewer2.org/#type=diverging&scheme=RdYlBu&n=7)

+ [Redes neuronales con *neuralnet*](https://www.datacamp.com/community/tutorials/neural-network-models-r)

+ [Agrupar por vector de caracteres en *dplyr*](https://stackoverflow.com/questions/36660152/concatenating-words-without-quotes-in-r-for-groupby-in-dplyr)

+ [Reordenar factores en *R*](https://www.r-bloggers.com/reorder-factor-levels/)

---

[Regresar](#tabla-de-contenido)
