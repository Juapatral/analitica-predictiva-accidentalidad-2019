---
title: <b><center>Análisis y pronóstico de la información accidentalidad vehicular en el municipio de Medellín para los años 2014 a 2018</center></b>

author: <center>Lina María Grajales Vanegas <br> Juan Camilo Agudelo Marín <br> Jhon Anderson Lonoño Herrera <br> Juan Pablo Trujillo Alviz <br><br> Estudiantes del Posgrado en Analítica <br> Universidad Nacional de Colombia, Medellín</center>

date: "11 de agosto de 2019"

output:
  html_document:
    #toc: true
    #toc_depth: 5
    #toc_float: 
    #  collapsed: true
    #  smooth_scroll: true
    #toc_width: 5
    theme: cerulean
    highlight: default
    df_print: paged
    fig_width: 9
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## **Tabla de contenido**
 
1. [Introducción](#introduccion)

    1.1. [Motivación](#motivacion)
    
    1.2. [Metodología](#metodologia)

2. [Desarrollo](#desarrollo)

    2.1. [Identificación del problema](#identificacion-del-problema)
    
    2.2. [Identificación de los datos](#identificacion-de-los-datos)
    
    2.3. [Descripción de los datos](#descripcion-del-conjunto-de-datos)<br>
    
    2.3.1. [Limpieza y resumen](#limpieza-y-resumen-de-los-datos)<br>
    2.3.2. [Análisis de los datos](#analisis)<br>
    2.3.3. [Tratamiento de datos atípicos](#datos-atipicos-o-nulos)<br>
        
    2.4. [Modelación de los datos](#modelacion-de-los-datos)
    
    2.5. [Evaluación del modelo](#evaluacion-del-modelo)
    
    2.6. [Implementación del modelo](#implementacion)
    
3. [Conclusiones](#conclusiones)

4. [Bibliografía](#bibliografia)


## **1. Introducción**

Cada día se generan cantidades enormes de datos que reposan en los sistemas de información y bases de datos públicas o privadas. Es de interés para los analístas de datos obtener la mayor cantidad de información valiosa y confiable de estos datos, generando valor agregado a las entidades y así incidir en la toma de decisiones para mejorar los procesos internos y, por ende, los resultados económicos y sociales de la entidad. (**FALTA UNA REFERENCIA**)

Por esta razón, los estudiantes de la materia Analítica Predictiva del Posgrado de Analítica de la Universidad Nacional de Colombia tienen como objetivo identificar y dar solución a un problema utilizando las técnicas estadísticas y de ciencia de datos que consideren óptimas. 

### **1.1. Motivación**

La materia de Analítica Predictiva en el Posgrado de Analítica de la Universidad Nacional de Colombia enseña algunas técnicas estadísticas para el pronóstico y clasificación de datos, utilizando los conceptos de la estadística descriptiva y probabilística como cálculo de probabilidades, Teorema de Bayes, medidas de tendencia, funciones de distribuciones de probabilidad, pruebas de hipótesis, entre otros. Algunos de los modelos vistos en clase fueron:

* K vecinos cercanos (k-nearest-neighbors)
* Regresión lineal (univariada y multivariada) 
* Regresión Ridge y Lasso (Casos de multicolinealidad de la regresión lineal)
* Regresión logística (logit)
* Árboles de decisión y regresión (Decision Tree)
* Bosques aleatorios (Random Forest)
* K medias (K-means)
* Agrupamiento jerárquico (cluster)
* Máquinas de soporte vectorial (SVM)
* Redes neuronales (Neural Network)
* Validación cruzada (Cross validation)


El objetivo de este trabajo es entrenar un modelo predictivo que permita encontrar solución a un problema propuesto por los estudiantes. Este problema deberá contar con suficiente información para estimar el modelo y este no debe estar sobreentrenado. 

Los entregables del trabajo son:

1. Código de ejecución del modelo. (disponible [aquí](https://google.com.co))
2. Reporte que contenga el entendimiento desarrollado en el trabajo, bibliografía de soporte y la metodología seguida debidamente justificada. (disponible [aquí](https://google.com.co))
3. Aplicativo web que permita visualizar los datos y la predicción del modelo. (disponible [aquí](https://google.com.co)).
4. Video promocional del aplicativo web, explicando su funcionalidad. (disponible [aquí](https://youtube.com)) 

Para este trabajo se decidió utilizar la información anonimizada de los registros del Impuesto de Industria y Comercio entre los años 2013 y 2018, proporcionada por la Alcaldía de Medellín.

### **1.2. Metodología**

Se propone utilizar la metodología [CRISP-DM](https://jdvelasq.github.io/ruta-n-predictiva/_downloads/5731da83c31e211e9b774ae8713246ed/CRISP-DM.pdf) en la que se sigue un flujo de trabajo para la identificación del problema y la propuesta, evaluación e implementación de la solución. Los pasos de la metodología *CRISP-DM* son los siguientes:

1. Identificación del problema del negocio (Va en desarrollo, **QUIEN**)

2. Identificación del problema de datos (Va en desarrollo, **QUIEN**)

3. Preparación de los datos (Estadística descriptiva, **Lina JP**)

4. Modelación (Elegir modelo, programar, **QUIEN**)

5. Evaluación (Verificación del modelo, aplicabilidad, **QUIEN**)

6. Implementación (Aplicativo web, video. **Jhon, JC**)

[Regresar](#tabla-de-contenido)

## **2. Desarrollo**

### **2.1. Identificación del problema**

La accidentalidad vial en las ciudades se ha ido posicionando año tras año como uno de los problemas que más costos sociales y económicos genera, hasta llegar a denominarse como “pandemia”. Medellín no ha sido la excepción y en la actualidad buena parte de las políticas públicas se movilizan para mitigar este fenómeno.
Se estima que anualmente los costos totales por accidentalidad solo para Medellín son cerca de $ 1,8 billones, así que este es un problema cuya minimización puede dejar muchas ganancias.
Una herramienta importante y base para la toma de decisiones es una estimación precisa que explique el problema y que permita predecir cuando y donde puede suceder determinado tipo de accidente.   
Esta estimación es útil para diferentes actores. Los hacedores de políticas podrán determinar qué zonas son susceptibles de reestructuración de la malla vial, donde deben enfocar los esfuerzos de capacitación, en qué lugares deben disponer de más servidores para la prevención y atención de los accidentes. Para el público en general le resultará de interés para tomar decisiones de movilidad, cuando transitar y en qué; o en decisiones de vivienda, que sectores se deben evitar cuando se tienen hijos, por ejemplo.
Nuestro trabajo pretende responder a estas preguntas y brindarle a la ciudad a través de una única plataforma la posibilidad visibilizar riesgos y con ello mitigarlos.


[Regresar](#tabla-de-contenido)

### **2.2. Identificación de los datos**

**FALTA**

[Regresar](#tabla-de-contenido)

### **2.3. Descripción del conjunto de datos**

Para el análisis de la información se utilizará el dialecto *Tidyverse* y los paquetes *data.table*, *plotly*, *rmarkdown*, *shiny* y **FALTA PAQUETES MODELO**.

```{r Paquetes, message=FALSE, warning=FALSE}
# se instalan los paquetes necesarios

#install.packages("tidyverse")    # dialecto de ciencia de datos
#install.packages("data.table")   # manejo de tablas
#install.packages("plotly")       # graficas semi-dinamicas
#install.packages("rmarkdown")    # utilizar rmarkdown
#install.packages("shiny")        # tableros de control dinamicos
#install.packages("prettydoc")    # dar formato a rmarkdown
```

**FALTA**

[Regresar](#tabla-de-contenido)

#### **2.3.2. Análisis**

**FALTA**

Unificar datos

```{r lectura_consolidado, message=FALSE, warning=FALSE}
# cargar librerias
library(data.table)   # manejo de tablas
library(purrr)        # optimizacion de bucles
library(dplyr)        # manejo de tablas
library(plotly)       # graficos en html
library(tidyr)        # limpieza de datos
library(stringr)      # limpieza de texto
library(lubridate)    # limpieza de fechas
library(sf)           # manejo de archivos espaciales

# lista archivos
lista <- list.files(pattern = "^Acc.*.csv", include.dirs = T, recursive = T)

# leer todos los archivos
lista_df <- map(lista, fread, sep = ",", encoding = "UTF-8", colClasses = "c")

# agregar archivos del 2014 a 2018
acc <- bind_rows(lista_df)

# ver cabecera del archivo
head(acc)
```

## limpieza de acc
```{r message=FALSE, warning=FALSE}
# organizar fecha
acc$FECHA <- ymd(gsub(pattern = "T.*", replacement = "", acc$FECHA),
                  "%Y-%M-%D")[1:209426]

# eliminar datos nulos y corregir clase
acc <- acc[-which(acc$CLASE == ""),]
acc$CLASE <- iconv(acc$CLASE, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$CLASE <- gsub("DE ", "", toupper(acc$CLASE))

# eliminar datos nulos y corregir disenio
acc <- acc[-which(acc$DISENO == ""),]
acc$DISENO <- iconv(acc$DISENO, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$DISENO <- gsub("DE ", "", toupper(acc$DISENO))

# corregir tildes de DIA_NOMBRE
acc$DIA_NOMBRE <- iconv(acc$DIA_NOMBRE, from = "UTF-8", to = "ASCII//TRANSLIT")

# crear columna de comuna_barrio
acc <- mutate(acc, COMUNA_BARRIO = str_sub(CBML, 1, 4))

```

## archivo espacial de barrios
```{r}
# cargar archivo shp de barrios de medellin
barrio <- read_sf("files/Limite_Barrio_Vereda_Catastral/Limite_Barrio_Vereda_Catastral.shp")

# unir columnas de nombre barrio y comuna
acc <- inner_join(acc, 
                  select(barrio, CODIGO, NOMBRE_COM, NOMBRE_BAR),
                  by = c("COMUNA_BARRIO" = "CODIGO"))
  
# limpiar nombre de barrios
acc$NOMBRE_BAR <- iconv(acc$NOMBRE_BAR, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$NOMBRE_BAR <- toupper(acc$NOMBRE_BAR)

# eliminar posibles duplicados por errores de union
acc <- data.table:::unique.data.table(acc, by = "RADICADO")

# eliminar columnas
acc <- select(acc, -BARRIO, -COMUNA, -OBJECTID, -RADICADO, -DIRECCION_ENC,
              -DIRECCION, -HORA, -CBML, -TIPO_GEOCOD, -MES_NOMBRE, -geometry)

# renombrar
names(acc)[12:13] <- c("COMUNA","BARRIO")
```
## ingreso de base de días especiales, limpieza de la base y unión con el archivo de accidentes.

```{r}
festivos <- fread("files/festivos_y_especiales.csv", header = T)
festivos[,names(festivos)[-1]] <- festivos%>%transmute_at(c(names(festivos)[-1]),funs(ifelse(. == "X","Si", ifelse(. == "","No",.))))
festivos$FECHA <- ymd(festivos$FECHA)[1:172]

head(acc)
```

# Juntar las base de festivos con acc y limpiar NA
```{r}
acc <- merge(x=acc,y=festivos, by ="FECHA", all.x = T)
acc[,names(festivos)[-1]]<-acc%>%transmute_at(c(names(festivos)[-1]),funs(ifelse(is.na(.),"No",.)))
head(acc)
```

## Guardar archivo
```{r}
# convertir a utf8
acc[,2:27] <- map(.x = acc[,2:27], .f = enc2utf8)

# guardar archivo
fwrite(acc, "files/accidentalidad_georreferenciada_completa.csv", sep = ",")

# eliminar archivo y limpiar memoria
rm(acc)
gc(reset = T)
```

**Nota:** para algunos equipos y versiones puede que la limpieza no funcione correctamente, por lo que se recomienda volver a cargar el archivo a partir de este punto y no ejecutar el código anterior

```{r}
# volver a cargar el archivo
acc <- fread("files/accidentalidad_georreferenciada_completa.csv",
             sep = ",",
             encoding = "UTF-8")

# organizar fecha
acc$FECHA <- ymd(acc$FECHA)

# visualizar
head(acc)
```

Primero realizaremos un análisis descriptivo univariado de las variables por el número de accidentes registrados 
# Accidentes por comuna
```{r}
acc_comuna <- acc %>% 
              group_by(COMUNA) %>% 
              summarize(total_registros = n())
ggplot(data=acc_comuna, aes(x=COMUNA, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = .8)+
    xlab("Comuna")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por comuna")+ #título del gráfico
    coord_flip()


```
El mayor número de accidentes ocurre en La candelaria, seguido por Laureles y Castilla.

## Número de accidentes por mes
```{r}
acc_mes <- acc %>% 
              group_by(MES) %>% 
              summarize(total_registros = n())
ggplot(data=acc_mes, aes(x=MES, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = 
    .8)+
    xlab("Mes")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por mes") #título del gráfico
```
En el mes donde mayor cantidad de accidentes ocurre es en Agosto.

# Accidentalidad por día
```{r}
acc_nombredia <- acc %>% 
              group_by(DIA_NOMBRE) %>% 
              summarize(total_registros = n())
acc_nombredia$DIA_NOMBRE<-ordered(acc_nombredia$DIA_NOMBRE,levels=c( "LUNES", "MARTES", "MIERCOLES", "JUEVES", "VIERNES", "SABADO","DOMINGO"))

ggplot(data=acc_nombredia, aes(x=DIA_NOMBRE, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = 
    .8)+
    xlab("Días")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por días de la semana") #título del gráfico
```

Los viernes son los días que mayor accidentalidad presenta y el día con menos accidentalidad es el domingo.

# Accidentalidad por año
```{r}
acc_ano <- acc %>% 
              group_by(PERIODO) %>% 
              summarize(total_registros = n())
ggplot(data=acc_ano, aes(x=PERIODO, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = 
    .8)+
    xlab("Año")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por año") #título del gráfico
```
El año 2016 fue el año con mayor accidentalidad mientras que 2018 tuvo menos accidentes.

# Accidentalidad por tipo de accidente
```{r}
acc_clase <- acc %>% 
              group_by(CLASE) %>% 
              summarize(total_registros = n())
ggplot(data=acc_clase, aes(x=CLASE, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = 
    .8)+
    xlab("Tipo de accidente")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por tipo de accidente") #título del gráfico
```
El menor número de accidentes ocurre por incendio mientras que los choques son los que generan mayores accidentes de tránsito.

# Accidentes por gravedad
```{r}
acc_gravedad <- acc %>% 
              group_by(GRAVEDAD) %>% 
              summarize(total_registros = n())
ggplot(data=acc_gravedad, aes(x=GRAVEDAD, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = 
    .8)+
    xlab("Gravedad del accidente")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por gravedad del accidente") #título del gráfico
```
Desde el 2014 hasta el 2018 se tuvieron un número mayor de heridos que de daños.

# Accidentes por diseño
```{r}
acc_diseno <- acc %>% 
              group_by(DISENO) %>% 
              summarize(total_registros = n())
ggplot(data=acc_diseno, aes(x=DISENO, y=total_registros)) + 
    geom_bar(stat="identity", position="dodge", fill = "blue3", color = "grey48", alpha = 
    .8)+
    xlab("Diseño de la vía")+ # eje x
    ylab("Total registros")+ # eje y
    ggtitle("Número de accidentes por tipo de vía")+ #título del gráfico
    coord_flip()
```
La mayor cantidad de accidentes se presentan en los tramos de vía seguidos por las intersecciones.

Ahora analizaremos las variables agrupadas por la clase de accidente.

# Agrupar Clase-Gravedad
```{r}
acc_group_clase<- acc %>% group_by(CLASE, GRAVEDAD) %>% summarize(conteo = n())

ggplot(data=acc_group_clase, aes(x=CLASE, y=conteo, fill=GRAVEDAD)) + 
    geom_bar(stat="identity", position="dodge")+
    coord_flip()
```
De acuerdo al tipo de accidente, vemos que los choques generan una mayor cantidad de daños y la mayor cantidad de heridos.

# Agrupar clase-Mes
```{r}
acc_group_mes<- acc %>% group_by(MES,CLASE) %>% summarize(conteo = n()) 
ggplot(data=acc_group_mes, aes(x=CLASE, y=conteo, fill=MES)) + 
    geom_bar(stat="identity", position="dodge")
```
La mayor cantidad de choques se presenta en agosto.

# Agrupar Clase-Periodo
```{r}
acc_group_year<- acc %>% group_by(CLASE, PERIODO) %>% summarize(conteo = n()) 
ggplot(data=acc_group_year, aes(x=CLASE, y=conteo, fill=PERIODO)) + 
    geom_bar(stat="identity", position="dodge")+
    scale_fill_manual(values=c("#d0d1e6", "#bdc9e1","#74a9cf","#2b8cbe","#045a8d"))

```

# Gráfica Clase-Periodo
```{r}
acc_group_dia<- acc %>% group_by(CLASE, DIA_NOMBRE) %>% summarize(conteo = n()) 

ggplot(data=acc_group_dia, aes(x=CLASE, y=conteo, fill=DIA_NOMBRE)) + 
    geom_bar(stat="identity", position="dodge")+
    scale_fill_manual(values=c("#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#d1e5f0", "#92c5de"))+
  coord_flip()
```

# Gráfica Clase-festivo
```{r}
acc_group_festivo<- acc %>% group_by(CLASE, FESTIVO) %>% summarize(conteo = n()) 

ggplot(data=acc_group_festivo, aes(x=CLASE, y=conteo, fill=FESTIVO)) + 
    geom_bar(stat="identity", position="dodge")
```

# Registro de accidentalidad por día
```{r}
acc_fecha <- acc %>% 
              group_by(FECHA) %>% 
              summarize(total_registros = n())

plot_ly (data=subset(acc_fecha,subset = (FECHA<="2018-12-31")),
         x = ~FECHA,
         y = ~total_registros,
         type = "scatter" ,mode = "lines",
         line=list(width=1,color='rgb(205, 12, 24)'))%>%
         layout(title='Registros de accidentalidad',
         xaxis=list(title="Día"),
         yaxis=list(title="Total registros"))

```

# Accidentalidad por año

```{r}
acc_fecha$year<-format(acc_fecha$FECHA,"%Y")
plot_ly (data=subset(acc_fecha,subset = (FECHA<="2018-12-31")),
         x = ~FECHA,
         y = ~total_registros,
         type = "scatter" ,mode = "lines",
         split = ~year,
         line=list(width=1))%>%
  layout(title='Registros de accidentalidad',
         xaxis=list(title="Día"),
         yaxis=list(title="Total registros"))
```
   
Utilicemos la función aggregate para obtener el promedio diario para cada año de registros de accidentes:
```{r}
aggregate(total_registros~year,data=acc_fecha,FUN=mean)
```
Ahora obtengamos el promedio diario para cada mes y cada año:
```{r}
acc_fecha$Fecha<-as.Date(acc_fecha$FECHA,"%d/%m/%Y")
acc_fecha$mes<-format(acc_fecha$Fecha,"%m")
with(acc_fecha, month.abb[mes])
acc_fecha$mes<-strftime(acc_fecha$Fecha, format = "%B")
acc_fecha$mes<-ordered(acc_fecha$mes,levels=c( "enero", "febrero", "marzo", 
"abril", "mayo", "junio","julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"))
aggregate(total_registros~year*mes,data=acc_fecha,FUN=mean)%>%
  plot_ly(x = ~mes,
         y = ~total_registros,
         type = "scatter" ,mode = "lines",
         split = ~year,
         line=list(width=1))%>%
  layout(title='Promedio diario mensual de accidentes registrados',
         xaxis=list(title="Día"),
         yaxis=list(title="Total registros"))
```

Ahora utilicemos el diagrama de caja y bigotes para explorar relaciones:

```{r}
plot_ly (data=subset(acc_fecha,subset = (Fecha<="2018-12-31")),
         x = ~year,
         y = ~total_registros,
         type = "box")%>%
  layout(title='Registros de accidentes',
         xaxis=list(title="Año"),
         yaxis=list(title="Total registros"))
```

Ahora, hacemos algo similar a lo anterior para los meses del año y los días de la semana:

Veamos el diagrama de caja y bigotes para cada mes:

```{r}
acc_fecha$diames<-format(acc_fecha$Fecha,"%d")
plot_ly (data=subset(acc_fecha,subset = (Fecha<="2018-12-31")),
         x = ~mes,
         y = ~total_registros,
         type = "box")%>%
  layout(title='Registros de accidentes',
         xaxis=list(title="Mes"),
         yaxis=list(title="Total registros"))
```
Para cada día de la semana:

```{r}
acc_fecha$dia_semana<-weekdays(acc_fecha$Fecha)
acc_fecha$dia_semana<-ordered(acc_fecha$dia_semana,levels=c( "lunes", "martes", "miércoles", "jueves", "viernes", "sábado","domingo"))
plot_ly (data=subset(acc_fecha,subset = (Fecha<="2018-12-31")),
         x = ~dia_semana,
         y = ~total_registros,
         type = "box")%>%
  layout(title='Registros de accidentes',
         xaxis=list(title="Mes"),
         yaxis=list(title="Total registros"))
```
[Regresar](#tabla-de-contenido)

#### **2.3.3. Datos atípicos o nulos**

**FALTA**


[Regresar](#tabla-de-contenido)

### **2.4. Modelación de los datos**
#se escogen tres agruoamientos para verificar el modelo.

```{r}
acc_agrupado_0 <- acc%>%group_by(FECHA,CLASE,DISENO,DIA_NOMBRE,DIA,PERIODO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(CLASE,FECHA)
acc_agrupado_0$DIA <- as.integer(acc_agrupado_0$DIA)
acc_agrupado_0$PERIODO <- as.integer(acc_agrupado_0$PERIODO)


acc_agrupado_1<-acc%>%group_by(FECHA,CLASE,DIA_NOMBRE,DIA,PERIODO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(CLASE,FECHA)
acc_agrupado_1$DIA <- as.integer(acc_agrupado_1$DIA)
acc_agrupado_1$PERIODO <- as.integer(acc_agrupado_1$PERIODO)

acc_agrupado_2 <-acc%>%group_by(FECHA,DIA_NOMBRE,PERIODO,CLASE,MES,DIA,COMUNA_BARRIO,COMUNA,BARRIO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(CLASE,FECHA)
acc_agrupado_2$DIA <- as.integer(acc_agrupado_2$DIA)
acc_agrupado_2$PERIODO <- as.integer(acc_agrupado_2$PERIODO)
```


# agrupamiento de datos para el modelado
```{r}
acc_agrupado_0 <- acc%>%group_by(FECHA,CLASE,DISENO,DIA_NOMBRE,DIA,PERIODO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(CLASE,FECHA)
acc_agrupado_0$DIA <- as.integer(acc_agrupado_0$DIA)
acc_agrupado_0$PERIODO <- as.integer(acc_agrupado_0$PERIODO)


acc_agrupado_1<-acc%>%group_by(FECHA,CLASE,DIA_NOMBRE,DIA,PERIODO,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(CLASE,FECHA)
acc_agrupado_1$DIA <- as.integer(acc_agrupado_1$DIA)
acc_agrupado_1$PERIODO <- as.integer(acc_agrupado_1$PERIODO)

acc_agrupado_2 <-acc%>%group_by(FECHA,DIA_NOMBRE,PERIODO,CLASE,MES,DIA,COMUNA,FESTIVO,MADRE,NAVIDAD,BRUJITOS,SEMSANTA,ESCOLAR)%>%summarise(ACCIDENTES=n())%>%arrange(CLASE,FECHA)
acc_agrupado_2$DIA <- as.integer(acc_agrupado_2$DIA)
acc_agrupado_2$PERIODO <- as.integer(acc_agrupado_2$PERIODO)
```


#Elección del modelo de regresion


```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_0<-lm(ACCIDENTES~FECHA+CLASE+DISENO+DIA_NOMBRE+PERIODO+FESTIVO+MADRE+NAVIDAD+BRUJITOS+SEMSANTA+ESCOLAR,data=acc_agrupado_0, subset = (FECHA<="2017-12-31"))
summary(modelo_lm)
```


```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+DIA+PERIODO+FESTIVO+MADRE+NAVIDAD+BRUJITOS+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```
#al verificar los valores P, se opta por retirar la variable brujitos
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+DIA+PERIODO+FESTIVO+MADRE+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```
#No se observa nigun cambio en el R cuadrado ajustado. se opta por quitar DIA. 
```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+MADRE+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```
#No se observa nigun cambio en el R cuadrado ajustado. se opta por quitar MADRE. 

```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```
#No se observa nigun cambio en el R cuadrado ajustado. se opta por quitar ESCOLAR. 
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)

```{r}
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```
#dado que al quitar la variable anterior el R cuadrado ajustado bajo 0.0001, por lo cual se opta por dejar el modelo con la variable ESCOLAR.


```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1<-lm(ACCIDENTES~FECHA+CLASE+DIA_NOMBRE+PERIODO+FESTIVO+NAVIDAD+SEMSANTA+ESCOLAR,data=acc_agrupado_1, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_1)
```

#Se escoge el agrupado 2 para determinar si este tiene un mejor ajuste.

```{r}
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_2<-lm(ACCIDENTES~FECHA+DIA_NOMBRE+PERIODO+CLASE+MES+DIA+COMUNA+FESTIVO+MADRE+NAVIDAD+BRUJITOS+SEMSANTA+ESCOLAR,data=acc_agrupado_2, subset = (FECHA<="2017-12-31"))
summary(modelo_lm_2)
```

#agregandola variable de comunas, vemos que el modelo es menos significativo que e agrupado 1 por lo que optamos por hacer la validacion con el modelo del agrupado 1.







**FALTA**

[Regresar](#tabla-de-contenido)

### **2.5. Evaluación del modelo**

**FALTA**

[Regresar](#tabla-de-contenido)

### **2.6. Implementación**

**FALTA**

[Regresar](#tabla-de-contenido)

## **3. Conclusiones**

**FALTA**

[Regresar](#tabla-de-contenido)

## **4. Bibliografía**

**FALTA**

**R Markdown**

+ [Infografía de *Rmarkdown*](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)

+ [API de *Rmarkdown*](https://bookdown.org/yihui/rmarkdown/)

---

**Plotly**

+ [API de *Plotly*](https://plot.ly/r/reference/)

---

**Shiny**

+ [API de *Shiny*](http://shiny.rstudio.com/articles/basics.html)

+ [Incrustar videos en *Shiny*](https://stackoverflow.com/questions/43740470/embed-instagram-youtube-into-shiny-r-app)

+ [Rango de fechas en *Shiny*](https://shiny.rstudio.com/gallery/date-and-date-range.html)

+ [Pestañas en *Shiny*](https://shiny.rstudio.com/articles/tabsets.html)

+ [Incrustar HTML y Markdown en *Shiny*](http://shiny.rstudio.com/gallery/including-html-text-and-markdown-files.html)

+ [Lista desplegable en Shiny](https://shiny.rstudio.com/reference/shiny/latest/selectInput.html)

---

**Demás**

+ [link aquí](https://wikipedia.com)

---

[Regresar](#tabla-de-contenido)
