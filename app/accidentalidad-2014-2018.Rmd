---
title: <b><center>Análisis y pronóstico de la información accidentalidad vehicular en el municipio de Medellín para los años 2014 a 2018</center></b>

author: <center>Lina María Grajales Vanegas <br> Juan Camilo Agudelo Marín <br> Jhon Anderson Lonoño Herrera <br> Juan Pablo Trujillo Alviz <br><br> Estudiantes del Posgrado en Ingeniería Analítica <br> Universidad Nacional de Colombia, Medellín</center>

date: "11 de agosto de 2019"

output:
  html_document:
    #toc: true
    #toc_depth: 5
    #toc_float: 
    #  collapsed: true
    #  smooth_scroll: true
    #toc_width: 5
    theme: cerulean
    highlight: default
    df_print: paged
    fig_width: 9
    fig_height: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)
```
## **Resumen**

>*En cada instante se generan grandes volúmenes de datos y es de interés para los analístas obtener información valiosa y confiable de estos y así incidir en la toma de decisiones para mejorar los resultados económicos y sociales de una empresa, institución o la sociedad en general. Un ejemplo de estos datos masivos se reflan en la accidentalidad vial, que se ha posicionado año tras año como uno de los problemas que más costos sociales y económicos genera. Medellín no ha sido la excepción y en la actualidad buena parte de las políticas públicas se movilizan para mitigar este fenómeno.* 

>*En este trabajo se decidió utilizar la información de la accidentalidad vehicular en el municipio de Medellín para los años 2014 a 2018 con el fin de pronosticar la frecuencia de accidentes agrupada según su tipo para el año 2019. Se evaluaron tres tipos de modelos: la regresión lineal multivariada, regresión lineal generalizada con distribuación Poisson y árbol de decisiones. Algunos de los factores que tenían una influencia fuerte sobre el fenomeno son el tipo de accidente, la fecha y si esta corresponde a un día especial (como festivo o semana santa). Se encontró que un modelo de regresión lineal generalizado de distribución Poisson se acerca más al comportamiento real del fenomeno.*

## **Tabla de contenido**
 
1. [Introducción](#introduccion)

    1.1. [Motivación](#motivacion)
    
    1.2. [Metodología](#metodologia)

2. [Desarrollo](#desarrollo)

    2.1. [Identificación del problema](#identificacion-del-problema)
    
    2.2. [Identificación de los datos](#identificacion-de-los-datos)
    
    2.3. [Descripción de los datos](#descripcion-del-conjunto-de-datos)<br>
    
    2.3.1. [Limpieza y resumen](#limpieza-y-resumen-de-los-datos)<br>
    2.3.2. [Análisis de los datos](#analisis)<br>
    2.3.3. [Tratamiento de datos atípicos](#datos-atipicos-o-nulos)<br>
        
    2.4. [Modelación de los datos](#modelacion-de-los-datos)
    
    2.5. [Evaluación del modelo](#evaluacion-del-modelo)
    
    2.6. [Implementación del modelo](#implementacion)
    
3. [Conclusiones](#conclusiones)

4. [Bibliografía](#bibliografia)


## **1. Introducción**

Cada día se generan cantidades enormes de datos que reposan en los sistemas de información y bases de datos públicas o privadas. Es de interés para los analistas de datos obtener la mayor cantidad de información valiosa y confiable de estos datos, generando valor agregado a las entidades y así incidir en la toma de decisiones para mejorar los procesos internos y, por ende, los resultados económicos y sociales de la entidad. 

Por esta razón, los estudiantes de la materia Analítica Predictiva del Posgrado de Analítica de la Universidad Nacional de Colombia tienen como objetivo identificar y dar solución a un problema utilizando las técnicas estadísticas y de ciencia de datos que consideren óptimas. 

### **1.1. Motivación**

En la materia de Analítica Predictiva se enseñan algunas técnicas estadísticas para el pronóstico y clasificación de datos, utilizando los conceptos de la estadística descriptiva y probabilística como cálculo de probabilidades, Teorema de Bayes, medidas de tendencia, funciones de distribuciones de probabilidad, pruebas de hipótesis, entre otros. Algunos de los modelos vistos en clase fueron:

* K vecinos cercanos (k-nearest-neighbors)
* Regresión lineal (univariada y multivariada) 
* Regresión Ridge y Lasso (Casos de multicolinealidad de la regresión lineal)
* Regresión logística (logit)
* Árboles de decisión y regresión (Decision Tree)
* Bosques aleatorios (Random Forest)
* K medias (K-means)
* Agrupamiento jerárquico (cluster)
* Máquinas de soporte vectorial (SVM)
* Redes neuronales (Neural Network)
* Validación cruzada (Cross validation)


El objetivo de este trabajo es entrenar un modelo predictivo que permita encontrar solución a un problema propuesto por los estudiantes. Este problema deberá contar con suficiente información para estimar el modelo y este no debe estar sobreentrenado. 

Los entregables del trabajo son:

1. Código de ejecución del modelo. (disponible [aquí](https://juapatral.github.io/analitica-predictiva-accidentalidad-2019/app/accidentalidad-2014-2018.Rmd))
2. Reporte que contenga el entendimiento desarrollado en el trabajo, bibliografía de soporte y la metodología seguida debidamente justificada. (este mismo informe, disponible [aquí](https://juapatral.github.io/analitica-predictiva-accidentalidad-2019/app/accidentalidad-2014-2018.html))
3. Aplicativo web que permita visualizar los datos y la predicción del modelo. (disponible [aquí](https://google.com.co)).
4. Video promocional del aplicativo web, explicando su funcionalidad. (disponible [aquí](https://youtu.be/yK3SiymGsHs) )

### **1.2. Metodología**

Se propone utilizar la metodología [CRISP-DM](https://jdvelasq.github.io/ruta-n-predictiva/_downloads/5731da83c31e211e9b774ae8713246ed/CRISP-DM.pdf) en la que se sigue un flujo de trabajo para la identificación del problema y la propuesta, evaluación e implementación de la solución. Los pasos de la metodología *CRISP-DM* son los siguientes:

1. Identificación del problema del negocio.

2. Identificación del problema de datos.

3. Preparación y análisis de los datos.

4. Modelación.

5. Evaluación de los modelos y elección.

6. Implementación.

[Regresar](#tabla-de-contenido)

## **2. Desarrollo**

### **2.1. Identificación del problema**

La accidentalidad vial en las ciudades se ha ido posicionando año tras año como uno de los problemas que más costos sociales y económicos genera hasta llegar a denominarse como “pandemia”. Medellín no ha sido la excepción y en la actualidad buena parte de las políticas públicas se movilizan para mitigar este fenómeno. Se estima que anualmente los costos totales por accidentalidad solo para Medellín son cerca de $ 1,8 billones, así que este es un problema cuya minimización puede significar invertir recursos públicos en otros sectores.

Una herramienta importante y base para la toma de decisiones es una estimación precisa que explique el problema y que permita predecir cuándo y dónde puede suceder determinado tipo de accidente.   

Esta estimación es útil para diferentes actores. Los hacedores de política podrán determinar cuáles zonas son susceptibles de reestructuración de la malla vial, dónde deben enfocar los esfuerzos de capacitación o en cuáles lugares deben disponer de más servidores para la prevención y atención de los accidentes. Para el público en general le resultará de interés para tomar decisiones de movilidad, cuándo transitar y en qué; o en decisiones de vivienda, que sectores se deben evitar cuando se tienen hijos, por ejemplo.

En este trabajo se pretende responder a estas preguntas y brindarle a la ciudad la posibilidad de visibilizar la información de los accidentes vehiculares, sus riesgos asociados y así mitigarlos, a través de una única plataforma pública donde se realice un pronóstico del total de accidentes por tipo de accidente para el año 2019.

[Regresar](#tabla-de-contenido)

### **2.2. Identificación de los datos**

Para este trabajo se decidió utilizar la información de la accidentalidad vehicular en el municipio de Medellín para los años 2014 a 2018, disponibles al público en general en [este enlace.](https://geomedellin-m-medellin.opendata.arcgis.com/datasets/accidentalidad-georreferenciada-2018)

El conjunto de datos se compone de los accidentes de tránsito registrados por la Secretaría de Movilidad de la Alcaldía de Medellín, entre los años especificados. Se entiende por accidente de tránsito: "evento, generalmente involuntario, generado al menos por un  un vehículo en movimiento, que causa daños a personas y bienes involucrados en él, e igualmente afecta la normal circulación de los vehículos que se movilizan por la vía o vías comprendidas en el lugar o dentro de la zona de influencia del hecho". (Ley 769 de 2002 - Código Nacional de Tránsito)

La estructura de la tabla es la siguiente:

**Campo**|**Descripción**|**Tipo**|**Observación**
:--|--------|:-:|--------
OBJECTID|Identificación del registro (fila)|integer|Sin
X|Coordenada X (longitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
Y|Coordenada Y (latitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
RADICADO|Identificación única del accidente ante la Secretaría de Movilidad|string|Sin
HORA|Hora aproximada de la ocurrencia del accidente|datetime|Sin
DIA_NOMBRE|Nombre del día de la semana de la ocurrencia del accidente|string|Sin
PERIODO|Año de la ocurrencia del accidente|integer|Sin
CLASE|Tipo de accidente|string|Opciones entre: atropello, caída del ocupante, choque, incendio, volcamiento y otro.
DIRECCION|Dirección descriptiva de la ubicación de la ocurrencia del accidente|string|Sin
DIRECCION_ENC|Dirección encasillada de la ubicación de la ocurrencia del accidente|string|Formato único de direcciones en el sistema de información de la Alcaldía de Medellín
CBML|Identificación única del lote más cercano a la ubicación de la ocurrencia del accidente|string|Acrónimo de comuna, barrio, manzana, lote
TIPO_GEOCOD|Tipo de ubicación según información catastral|string|Más información en el geocodificador de la Alcaldía disponible [aquí](https://www.medellin.gov.co/geomedellin/index.hyg#openModal)
GRAVEDAD|Gravedad del accidente|string|Opciones entre: herido, muerto y solo daños
BARRIO|Barrio de la ubicación de la ocurrencia del accidente|string|Sin
COMUNA|Comuna de la ubicación de la ocurrencia del accidente|string|Sin
DISENO|Tipo de entramado de la ubicación de la ocurrencia del accidente|string|Opciones entre: ciclo ruta, glorieta. intersección, lote o predio, paso a nivel, paso elevado, paso inferior, pontón, puente, tramo vía, túnel o vía peatonal
MES|Número del mes de la ocurrencia del accidente|integer|Sin
DIA|Día del mes de la ocurrencia del accidente|integer|Sin
FECHA|Fecha de la ocurrencia del accidente|string|Formato [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
MES_NOMBRE|Nombre del mes de la ocurrencia del accidente|integer|Columna vacía

*Nota:* las coordenadas *Magna Medellín* corresponden a una transformación de las coordenadas elípticas internacionales [`wgs84`](https://en.wikipedia.org/wiki/World_Geodetic_System) a coordenadas planas propias establecidas por el Instituto Geográfico Agustín Codazzi (IGAC) en concordancia con el Subsecretaría de Catastro del municipio de Medellín. 

[Regresar](#tabla-de-contenido)

### **2.3. Descripción del conjunto de datos**

Para el análisis de la información se utilizará el dialecto *Tidyverse* para la limpieza de datos, los paquetes *data.table*, *plotly*, *rmarkdown*, *shiny* y *leaflet* para lectura y visualización y *stats*, *rpart* y *rpart.plot* para estimar los modelos.

```{r Paquetes, message=FALSE, warning=FALSE}
## se instalan y cargan los paquetes necesarios

# instalar paquetes
#install.packages("tidyverse")    # dialecto de ciencia de datos
#install.packages("data.table")   # manejo de tablas
#install.packages("ggplot2")      # manejo de graficas
#install.packages("plotly")       # graficas semi-dinamicas
#install.packages("grid")         # manejo de subgraficas
#install.packages("rmarkdown")    # utilizar rmarkdown
#install.packages("shiny")        # tableros de control dinamicos
#install.packages("prettydoc")    # dar formato a rmarkdown
#install.packages("sf")           # manejo de archivos espaciales (.shp)
#install.packages("leaflet")      # mapas dinamicos en HTML
#install.packages("rpart")        # arboles de decisiones
#install.packages("rpart.plot")   # graficar arboles

# cargar paquetes
library(data.table)   # manejo de tablas
library(purrr)        # optimizacion de bucles
library(dplyr)        # manejo de tablas
library(plotly)       # graficos en html
library(tidyr)        # limpieza de datos
library(stringr)      # limpieza de texto
library(lubridate)    # limpieza de fechas
library(sf)           # manejo de archivos espaciales
```

#### **2.3.1. Limpieza y resumen de los datos**

De manera inicial se leen los archivos.

**Nota al ejecutador de código:** para algunos sistemas operativos o versiones de paquetes la limpieza no funciona correctamente, por lo que se recomienda volver a cargar el archivo a partir [aquí.](#nueva-lectura)

```{r lectura_consolidado, message=FALSE, warning=FALSE}
## lectura de archivos

# lista archivos
lista <- list.files(pattern = "^Acc.*.csv", include.dirs = T, recursive = T)

# leer todos los archivos
lista_df <- map(lista, fread, sep = ",", encoding = "UTF-8", colClasses = "c")

# agregar archivos del 2014 a 2018
acc <- bind_rows(lista_df)

# ver cabecera del archivo
head(acc)
```

Se identifica que se deben hacer las siguientes correcciones en la tabla *acc*:

* Organizar la columna *FECHA* en formato [ISO 8601.](https://en.wikipedia.org/wiki/ISO_8601).

* Debido a la naturaleza del trabajo, se eliminan los nulos de la columna *CLASE* y se unifican los tipos de accidente, limpiando tildes y convirtiendo en mayúscula.

* De forma similar, se eliminan los nulos de la columna *DISENO*, se unifican los tipos de diseño, se limpian tildes y se convierte a mayúscula.

* Se eliminan las tildes de los días de la semana en la columna *DIA_NOMBRE*.

* Se crea la columna *COMUNA_BARRIO* a partir de la columna *CBML* con el objetivo de que sirva como clave foránea para la unión con el archivo espacial de barrios, disponible [aquí.](https://geomedellin-m-medellin.opendata.arcgis.com/datasets/limite-barrio-vereda-catastral) 
```{r primera_limpieza_acc, message=FALSE, warning=FALSE}
## limpieza de la tabla

# organizar fecha
acc$FECHA <- ymd(gsub(pattern = "T.*", replacement = "", acc$FECHA),
                 "%Y-%M-%D")[1:209426]

# eliminar datos nulos y corregir clase
acc <- acc[-which(acc$CLASE == ""),]
acc$CLASE <- iconv(acc$CLASE, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$CLASE <- gsub("DE ", "", toupper(acc$CLASE))

# eliminar datos nulos y corregir disenio
acc <- acc[-which(acc$DISENO == ""),]
acc$DISENO <- iconv(acc$DISENO, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$DISENO <- gsub("DE ", "", toupper(acc$DISENO))

# corregir tildes de DIA_NOMBRE
acc$DIA_NOMBRE <- iconv(acc$DIA_NOMBRE, from = "UTF-8", to = "ASCII//TRANSLIT")

# crear columna de comuna_barrio
acc <- mutate(acc, COMUNA_BARRIO = str_sub(CBML, 1, 4))

# visualizar nueva acc
head(acc)
```

Se procede a cargar el archivo espacial de barrios para identificar correctamente el barrio y la comuna de la ubicación del accidente. Luego, se realiza una nueva limpieza de la tabla *acc*:

* Se limpian las tildes de la columna barrio y se convierte a mayúscula.

* Se eliminan los registros duplicados generados por la unión. 

* Se eliminan algunas columnas no necesarias para el análisis.

* Se renombran las columnas de *NOMBRE_BAR* y *NOMBRE_COM* por *BARRIO* y *COMUNA* respectivamente.
```{r union_espacial, message=FALSE, warning=FALSE}
## carga de archivo espacial de barrios

# cargar archivo shp de barrios de medellin
barrio <- read_sf("files/Limite_Barrio_Vereda_Catastral/Limite_Barrio_Vereda_Catastral.shp")

# unir columnas de nombre barrio y comuna
acc <- inner_join(acc, 
                  select(barrio, CODIGO, NOMBRE_COM, NOMBRE_BAR),
                  by = c("COMUNA_BARRIO" = "CODIGO"))
  
# limpiar nombre de barrios
acc$NOMBRE_BAR <- iconv(acc$NOMBRE_BAR, from = "UTF-8", to = "ASCII//TRANSLIT")
acc$NOMBRE_BAR <- toupper(acc$NOMBRE_BAR)

# eliminar posibles duplicados por errores de union
acc <- data.table:::unique.data.table(acc, by = "RADICADO")

# eliminar columnas
acc <- select(acc, -BARRIO, -COMUNA, -OBJECTID, -RADICADO, -DIRECCION_ENC,
              -DIRECCION, -HORA, -CBML, -TIPO_GEOCOD, -MES_NOMBRE, -geometry)

# renombrar
names(acc)[12:13] <- c("COMUNA","BARRIO")

# visualizar acc
head(acc)
```

Se realiza la lectura de la tabla de días especiales, se limpia y se realiza unión con la tabla de accidentes. Además, se cambia las columnas tal que si es un día especial tenga la marcación *Si*, de lo contrario será *No*.
```{r dias_especiales, message=FALSE, warning=FALSE}
## carga de archivo de fechas especiales

# lectura del archivo
festivos <- fread("files/festivos_y_especiales.csv", header = T)

# convertir a si o no
festivos[,names(festivos)[-1]] <- festivos %>%
                                  transmute_at(c(names(festivos)[-1]),
                                               funs(ifelse(. == "X",
                                                           "Si", 
                                                           ifelse(. == "",
                                                                  "No",
                                                                  .)
                                                           )
                                                    )
                                               )

# convetir a formato fecha
festivos$FECHA <- ymd(festivos$FECHA)[1:172]

# visualizar festivos
head(festivos)
```

Se realiza la unión de las tablas y se convierten los datos de los días especiales a *No* en caso de que no haya encontrado coincidencia en la unión.
```{r union_dias_especiales, message=FALSE, warning=FALSE}
# union las tablas de dias especiales y accidentes

# union de tablas
acc <- merge(x = acc, y = festivos, by = "FECHA", all.x = T)

# transformar variables
acc[,names(festivos)[-1]] <- acc %>%
                             transmute_at(c(names(festivos)[-1]),
                                         funs(ifelse(is.na(.),
                                                     "No",
                                                     .)
                                              )
                                         )

# visualizar acc
head(acc)
```

Se realiza la conversión a la codificación [*UTF-8*](https://en.wikipedia.org/wiki/UTF-8) y se guarda el nuevo archivo.
```{r conversion-guardado, message=FALSE, warning=FALSE}
## guardar archivo definitivo 

# convertir a utf8
acc[,2:length(acc)] <- map(.x = acc[,2:length(acc)], .f = enc2utf8)

 # guardar archivo
fwrite(acc, "files/accidentalidad_georreferenciada_completa.csv", sep = ",")

# eliminar archivo y limpiar memoria
rm(acc)
gc(reset = T)
```

##### Nueva lectura
**Nota:** para algunos sistemas operativos o versiones de paquetes la limpieza no funciona correctamente, por lo que se recomienda volver a cargar el archivo a partir de este punto y no ejecutar el código anterior. 

```{r cargar-archivo, message=FALSE, warning=FALSE}
## carga de archivo definitivo

# volver a cargar el archivo
acc <- fread("files/accidentalidad_georreferenciada_completa.csv",
             sep = ",",
             encoding = "UTF-8")

# organizar fecha
acc$FECHA <- ymd(acc$FECHA)

# visualizar
head(acc)
```

Como se observa, la estructura de la tabla resultante es la siguiente:

**Campo**|**Descripción**|**Tipo**|**Observación**
:--|--------|:-:|--------
FECHA|Fecha de la ocurrencia del accidente|datetime|Formato [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
X|Coordenada X (longitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
Y|Coordenada Y (latitud) de la ubicación del accidente|float|Coordenadas en Magna Medellín. Ver nota. 
DIA_NOMBRE|Nombre del día de la semana de la ocurrencia del accidente|string|Sin
PERIODO|Año de la ocurrencia del accidente|integer|Sin
CLASE|Tipo de accidente|string|Opciones entre: atropello, caída del ocupante, choque, incendio, volcamiento y otro.
GRAVEDAD|Gravedad del accidente|string|Opciones entre: herido, muerto y solo daños
DISENO|Tipo de entramado de la ubicación de la ocurrencia del accidente|string|Opciones entre: ciclo ruta, glorieta. intersección, lote o predio, paso a nivel, paso elevado, paso inferior, pontón, puente, tramo vía, túnel o vía peatonal
MES|Número del mes de la ocurrencia del accidente|integer|Sin
DIA|Día del mes de la ocurrencia del accidente|integer|Sin
COMUNA_BARRIO|Identificador de la comuna y el barrio en el sistema de información de la Alcaldía|string|Sin
BARRIO|Barrio de la ubicación de la ocurrencia del accidente|string|Sin
COMUNA|Comuna de la ubicación de la ocurrencia del accidente|string|Sin
FESTIVO|Indicador de si el día es festivo o no|boolean|Opciones: Si o No
MADRE|Indicador de si el día es día de la madre o no|boolean|Opciones: Si o No
NAVIDAD|Indicador de si el día pertenece a las festividades de navidad o no|boolean|Opciones: Si o No
BRUJITOS|Indicador de si el día es el 31 de octubre o no|boolean|Opciones: Si o No
SEMSANTA|Indicador de si el día pertenece a la Semana Santa o no|boolean|Opciones: Si o No
ESCOLAR|Indicador de si el día pertenece a la época de vacaciones escolares o no|boolean|Opciones: Si o No

#### **2.3.2. Análisis**

Se realiza un análisis descriptivo para identificar las variables asociadas a la accidentalidad vial en la ciudad de Medellín a través del análisis y la interpretación de las cifras de accidentes registrados en la Secretaría de Movilidad.

Se crea una función para crear gráficos compuestos de varios subgráficos, la cual se llamará *multiplot*.
```{r funcion_subgraficos}
## funcion multiplot

#librerias para graficos y subgraficos
library(ggplot2)
library(grid)

# crear funcion multiplot
multiplot <- function(..., plotlist = NULL, file, cols = 1, layout = NULL) {

  # hacer una lista de los argumentos en ... y plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # si layout es NULL, entonces use columnas para establecerlo
  if (is.null(layout)) {
    # crear el panel
    # ncol: numero de columnas del grafico
    # nrow: numero de filas, calculado del numero de columnas
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, 
                     nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # configurar la pagina
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # poner cada grafico en la posicion correcta
    for (i in 1:numPlots) {
      # obtener la posicion i,j de la matriz de la region que va a contener 
      # el subgrafico
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

##### Accidentalidad por día, mes y año
La siguiente gráfica muestra el registro de accidentes por día, mes y año.
```{r grafica_dia_mes_anio, message=FALSE, warning=FALSE}
## grafica dia, mes y anio

# agrupar por nombre del dia
acc_nombredia <- acc %>% 
                 group_by(DIA_NOMBRE) %>% 
                 summarize(total_registros = n())

# establecer orden de los dias
acc_nombredia$DIA_NOMBRE <- ordered(acc_nombredia$DIA_NOMBRE, 
                                    levels = c( "LUNES", "MARTES", "MIERCOLES",
                                                "JUEVES", "VIERNES","SABADO",
                                                "DOMINGO")
                                    )
# grafica dia
p2 <- ggplot(data = acc_nombredia, aes(x = DIA_NOMBRE, y = total_registros)) + 
      geom_bar(stat = "identity", 
               position="dodge", 
               fill = "dodgerblue3", 
               color = "grey48", 
               alpha = 0.8) +
      xlab("Días") + # eje x
      ylab("Total registros") + # eje y
      # Girar label eje x
      theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5)) + 
      ggtitle("Número de accidentes por días de la semana") # titulo del grafico

# agrupar por mes
acc_mes <- acc %>% 
           group_by(MES) %>% 
           summarize(total_registros = n())

# grafica mes
p1 <- ggplot(data = acc_mes, aes(x = MES, y = total_registros)) + 
      geom_bar(stat = "identity", 
               position="dodge", 
               fill = "dodgerblue3", 
               color = "grey48", 
               alpha = 0.8) +
      xlab("Mes") + # eje x
      ylab("Total registros") + # eje y
      ggtitle("Número de accidentes por mes") # titulo del grafico

# agrupar por anio
acc_ano <- acc %>% 
           group_by(PERIODO) %>% 
           summarize(total_registros = n())

# grafica anio
p3 <- ggplot(data = acc_ano, aes(x = PERIODO, y = total_registros)) + 
      geom_bar(stat = "identity", 
               position = "dodge", 
               fill = "dodgerblue3", 
               color = "grey48", 
               alpha = 0.8) +
      xlab("Año") + # eje x
      ylab("Total registros") + # eje y
      ggtitle("Número de accidentes por año") # titulo del grafico

# crear multigrafico
multiplot(p1, p2, p3, cols = 2)
```

En está gráfica se puede observar que la mayor accidentalidad se presenta en el día viernes, durante el mes de agosto también hay un mayor número de accidentes y el 2016 fue el año con más accidentes durante el periodo de análisis (2014-2018), mientras que los días domingo, el mes de enero y en el año 2018 se registra una accidentalidad menor.

##### Accidentalidad por comuna y tipo de vía
```{r grafica_comuna_disenio}
## grafica comuna y disenio

# agrupar por comuna
acc_comuna <- acc %>% 
              group_by(COMUNA) %>% 
              summarize(total_registros = n())

# crear grafica comuna
p4 <- ggplot(data = acc_comuna, aes(x = COMUNA, y = total_registros)) +
      geom_bar(stat = "identity", 
               position = "dodge", 
               fill = "dodgerblue3", 
               color = "grey48", 
               alpha = 0.8) +
      xlab("Comuna") + # eje x
      ylab("Total registros") + # eje y
      ggtitle("Comuna") + # titulo del grafico
      coord_flip()

# agrupar por disenio de via
acc_diseno <- acc %>% 
              group_by(DISENO) %>% 
              summarize(total_registros = n())

# crear grafica disenio 
p5 <- ggplot(data = acc_diseno, aes(x = DISENO, y = total_registros)) +
      geom_bar(stat = "identity", 
               position = "dodge", 
               fill = "dodgerblue3", 
               color = "grey48",
               alpha = 0.8) +
      xlab("Diseño de la vía") + # eje x
      ylab("Total registros") + # eje y
      ggtitle("Tipo de vía") + # titulo del grafico
      coord_flip()

# crear multigrafico
multiplot(p4, p5, cols = 2)
```

El mayor número de accidentes ocurre en La Candelaria, seguido por Laureles-Estadio y Castilla. Los tramos en la vía es donde se presentan la mayor parte de los accidentes seguidos por las intersecciones.

##### Accidentalidad por tipo de accidente
```{r grafica_tipo, message=FALSE, warning=FALSE}
## grafica tipo de accidente

# agrupar por tipo de accidente
acc_clase <- acc %>% 
              group_by(CLASE) %>% 
              summarize(total_registros = n())

# crear grafica
p6 <- ggplot(data = acc_clase, aes(x = CLASE, y = total_registros)) +
      geom_bar(stat = "identity", 
               position = "dodge", 
               fill = "dodgerblue3", 
               color = "grey48", 
               alpha =0.8) +
      xlab("Tipo de accidente") + # eje x
      ylab("Total registros") + # eje y
      ggtitle("Número de accidentes por tipo de accidente") # titulo del gráfico

# visualizar grafica
p6
```

Se observa que la principal causa de los accidentes viales es debido a choques y son pocos los accidentes donde se termina con volcamiento de los vehículos.

##### Accidentalidad por gravedad ocasionada
```{r grafica_gravedad, message=FALSE, warning=FALSE}
## grafica gravedad

# agrupar por gravedad
acc_gravedad <- acc %>% 
              group_by(GRAVEDAD) %>% 
              summarize(total_registros = n())

# crear grafica
p7 <- ggplot(data = acc_gravedad, aes(x = GRAVEDAD, y = total_registros)) + 
      geom_bar(stat = "identity",
               position = "dodge", 
               fill = "dodgerblue3", 
               color = "grey48", 
               alpha = 0.8) +
      xlab("Gravedad del accidente") + # eje x
      ylab("Total registros")+ # eje y
      # titulo del grafico
      ggtitle("Número de accidentes por gravedad del accidente") 

# visualizar grafica
p7
```

Desde el 2014 hasta el 2018 se tuvo un número mayor de heridos que de daños.

##### **A continuación se analizan las variables agrupadas por la clase de accidente.**

##### Gráfico de gravedad de acuerdo al tipo de accidente
```{r grafica_clase_gravedad, message=FALSE, warning=FALSE}
## grafica tipo de accidente y gravedad

# agrupar por clase y gravedad
acc_group_clase <- acc %>% group_by(CLASE, GRAVEDAD) %>% summarize(conteo = n())

# graficar
ggplot(data = acc_group_clase, aes(x = CLASE, y = conteo, fill = GRAVEDAD)) +
  geom_bar(stat = "identity", position = "dodge") +
    coord_flip()
```

De acuerdo al tipo de accidente, se observa que los choques generan una mayor cantidad de daños y la mayor cantidad de heridos.

##### Clasificación de los tipos de accidentes por meses.
```{r grafica_clase_mes, message=FALSE, warning=FALSE}
## grafica tipo de accidente por mes

# agrupar por clase y mes
acc_group_mes <- acc %>% group_by(MES,CLASE) %>% summarize(conteo = n()) 

# graficar
ggplot(data = acc_group_mes, aes(x = CLASE, y = conteo, fill = MES)) + 
    geom_bar(stat = "identity", position = "dodge")
```

La mayor cantidad de choques se presenta en agosto.

##### Agrupación de tipo de accidente por año
```{r grafica_clase_anio, message=FALSE, warning=FALSE}
## grafica por tipo de accidente por anio

# agrupar por clase y periodo
acc_group_year <- acc %>% group_by(CLASE, PERIODO) %>% summarize(conteo = n()) 

# convertir periodo a categoria
acc_group_year$PERIODO <- as.factor(acc_group_year$PERIODO)

# graficar
ggplot(data = acc_group_year, aes(x = CLASE, y = conteo, fill = PERIODO)) +
    geom_bar(stat = "identity", position = "dodge") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))+
    scale_fill_manual(values = c("#d0d1e6",
                                 "#bdc9e1",
                                 "#74a9cf",
                                 "#2b8cbe",
                                 "#045a8d"))

```

##### Agrupación de tipo de accidente por día de la semana.
```{r grafica_clase_dia, message=FALSE, warning=FALSE}
## grafica por tipo de accidente por dia de la semana

# agrupar por clase y dia_nombre
acc_group_dia <- acc %>% group_by(CLASE, DIA_NOMBRE) %>% summarize(conteo = n()) 

# graficar
ggplot(data = acc_group_dia, aes(x = CLASE, y = conteo, fill = DIA_NOMBRE)) + 
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_manual(values = c("#eff3ff", 
                                 "#c6dbef", 
                                 "#9ecae1",
                                 "#6baed6", 
                                 "#4292c6", 
                                 "#2171b5", 
                                 "#084594")) +
    coord_flip()
```

Los viernes y los sábados son los días donde mayor cantidad de accidentes se presentan.

##### Tipo de accidente ocurrido en los días festivos.
```{r grafica_clase_festivo, message=FALSE, warning=FALSE}
## grafica por tipo de accidente los dias festivoos

# agrupar por clase y festivo
acc_group_festivo <- acc %>% 
                     group_by(CLASE, FESTIVO) %>% 
                     summarize(conteo = n()) 

# graficar
ggplot(data = acc_group_festivo, aes(x = CLASE, y = conteo, fill = FESTIVO)) + 
    geom_bar(stat = "identity", position = "dodge")
```

Se observa que los accidentes ocurridos se presentan en los días ordinarios y que la accidentalidad en los días festivos es baja.

##### **Series temporales**

Para guiar el análisis de la información resulta útil representar gráficamente los datos o una muestra de los mismos. En este caso, la variable a predecir es el número de accidentes viales registrados diariamente en la Secretaría de Movilidad y esta variable depende del tiempo, se desea representarla como una serie temporal.

##### Serie temporal de accidentalidad por día
```{r grafica_diaria, message=FALSE, warning=FALSE}
## grafica accidentes diarios

# agrupar
acc_fecha <- acc %>% 
             group_by(FECHA) %>% 
             summarize(total_registros = n())

# graficar
plot_ly (data = subset(acc_fecha,subset = (FECHA <= "2018-12-31")),
         x = ~FECHA,
         y = ~total_registros,
         type = "scatter",
         mode = "lines",
         line = list(width = 1, color = 'rgb(205, 12, 24)'))%>%
  layout(title = 'Registros de accidentalidad',
         xaxis = list(title = "Día"),
         yaxis = list(title = "Total registros"))
```

##### Serie temporal de accidentalidad por año
```{r grafica_anio, message=FALSE, warning=FALSE}
## grafica accidentes por anio

# crear columna de anio
acc_fecha$year <- format(acc_fecha$FECHA,"%Y")

# graficar
plot_ly (data = subset(acc_fecha, subset = (FECHA <= "2018-12-31")),
         x = ~FECHA,
         y = ~total_registros,
         type = "scatter",
         mode = "lines",
         split = ~year,
         line = list(width = 1))%>%
  layout(title = 'Registros de accidentalidad',
         xaxis = list(title = "Día"),
         yaxis = list(title = "Total registros"))
```
 
Usando la función *aggregate* se obtiene el promedio diario para cada año de registros de accidentes
```{r agregar_promedio_diario, message=FALSE, warning=FALSE}
## promedio diario

# agregar datos por promedio
aggregate(total_registros ~ year, data = acc_fecha, FUN = mean)
```

##### Promedio diario para cada mes y cada año
```{r grafica_promedio_diario, message=FALSE, warning=FALSE}
## grafica del promedio diario por mes y por anio

# crear columna mes
acc_fecha$Fecha <- as.Date(acc_fecha$FECHA, "%d/%m/%Y")
acc_fecha$mes <- format(acc_fecha$Fecha, "%m")
acc_fecha$mes <- strftime(acc_fecha$Fecha, format = "%B")

# ordenar columna mes 
acc_fecha$mes <- ordered(acc_fecha$mes, levels = c( "enero", "febrero", "marzo",
                                                    "abril", "mayo","junio",
                                                    "julio", "agosto",
                                                    "septiembre", "octubre",
                                                    "noviembre", "diciembre"))

# agregar datos por promedio mes y anio y graficar
aggregate(total_registros ~ year*mes, data = acc_fecha, FUN = mean) %>%
  plot_ly(x = ~mes,
          y = ~total_registros,
          type = "scatter",
          mode = "lines",
          split = ~year,
          line = list(width = 1)) %>%
  layout(title = 'Promedio diario mensual de accidentes registrados',
         xaxis = list(title="Día"),
         yaxis = list(title="Total registros"))
```

Se utilizará el diagrama de caja y bigotes para explorar relaciones y encontrar datos atípicos.

##### Diagrama de caja y bigotes de número de accidentes por año
```{r caja_anio, message=FALSE, warning=FALSE}
## grafica de caja y bigotes por anio

# graficar
plot_ly (data = subset(acc_fecha, subset = (Fecha <= "2018-12-31")),
         x = ~year,
         y = ~total_registros,
         type = "box")%>%
  layout(title = 'Registros de accidentes',
         xaxis = list(title = "Año"),
         yaxis = list(title = "Total registros"))
```


##### Diagrama de caja y bigotes para cada mes
```{r caja_mes, message=FALSE, warning=FALSE}
## grafica de caja y bigotes por mes

# crear columna de mes
acc_fecha$diames <- format(acc_fecha$Fecha, "%d")

# graficar
plot_ly (data = subset(acc_fecha, subset = (Fecha <= "2018-12-31")),
         x = ~mes,
         y = ~total_registros,
         type = "box")%>%
  layout(title = 'Registros de accidentes',
         xaxis = list(title = "Mes"),
         yaxis = list(title = "Total registros"))
```

##### Diagrama de caja y bigotes para cada día de la semana
```{r caja_semana, message=FALSE, warning=FALSE}
## grafica de caja y bigotes por dia de semana

# crear dia de semana
acc_fecha$dia_semana <- weekdays(acc_fecha$Fecha)
acc_fecha$dia_semana <- ordered(acc_fecha$dia_semana, 
                                levels = c( "lunes", "martes", "miércoles",
                                            "jueves", "viernes", "sábado",
                                            "domingo"))

# graficar
plot_ly (data = subset(acc_fecha, subset = (Fecha <= "2018-12-31")),
         x = ~dia_semana,
         y = ~total_registros,
         type = "box")%>%
  layout(title = 'Registros de accidentes',
         xaxis = list(title = "Mes"),
         yaxis = list(title = "Total registros"))
```

[Regresar](#tabla-de-contenido)

#### **2.3.3. Datos atípicos o nulos**

El manejo de datos nulos se dio en la [sección 2.3.1.](#limpieza-y-resumen-de-los-datos) donde se tomaron las siguientes decisiones:

* Si *CLASE* era nulo, se eliminaba por la naturaleza del objetivo.
* Si *DISENO* era nulo, se eliminaba por la naturaleza del objetivo.
* Si *COMUNA_BARRIO* era nulo o no estaba en la tabla de barrios, se eliminaba ya que posiblemente corresponda a un dato difícil de medir.

Después de realizar el análisis, se concluye que ningún dato atípico será eliminado ya que corresponden a los datos de las tablas originales, a los cuales se les aplicaron transformaciones mínimas.  

[Regresar](#tabla-de-contenido)

### **2.4. Modelación de los datos**

Con el fin de realizar el mejor pronóstico, se evaluarán tres tipos de modelos: la regresión lineal multivariada, regresión lineal generalizada con distribuación Poisson y árbol de decisiones. 

Además, es importante conocer cuáles variables entrarán en cada modelo, por lo que se escogen tres agrupamientos para verificar el modelo.

Estos grupos son:

+ **Grupo 0:** se toman en cuenta las variables de fecha, tipo de accidente, diseño de la vía y días especiales.

+ **Grupo 1:** se toman en cuenta las variables de fecha, tipo de accidente y dias especiales.

+ **Grupo 2:** se toman en cuenta las variables de fecha, tipo de accidente, comuna y días especiales.

Se crean los grupos:
```{r agrupamientos_modelos, message=FALSE, warning=FALSE}
## agrupamientos para los diferentes modelos

# grupo 0: fecha, tipo de accidente, diseno de via, dias especiales 
acc_agrupado_0 <- acc %>%
                  group_by(FECHA, CLASE, DISENO, DIA_NOMBRE, DIA,PERIODO,
                          FESTIVO, MADRE, NAVIDAD, BRUJITOS, SEMSANTA, 
                          ESCOLAR) %>%
                  summarise(ACCIDENTES = n()) %>% 
                  arrange(FECHA) # organizar por fecha

# convertir dia y periodo a enteros
acc_agrupado_0$DIA <- as.integer(acc_agrupado_0$DIA)
acc_agrupado_0$PERIODO <- as.integer(acc_agrupado_0$PERIODO)

# grupo 1: fecha, tipo de accidente, dias especiales
acc_agrupado_1 <- acc %>%
                  group_by(FECHA, CLASE, DIA_NOMBRE, DIA, PERIODO, FESTIVO, 
                           MADRE, NAVIDAD, BRUJITOS, SEMSANTA, ESCOLAR) %>%
                  summarise(ACCIDENTES = n()) %>%
                  arrange(FECHA) # organizar por fecha

# convertir dia y periodo a enteros
acc_agrupado_1$DIA <- as.integer(acc_agrupado_1$DIA)
acc_agrupado_1$PERIODO <- as.integer(acc_agrupado_1$PERIODO)

# grupo 2: fecha, clase, ubicacion, dias especiales, 
acc_agrupado_2 <- acc %>%
                  group_by(FECHA, DIA_NOMBRE, PERIODO, CLASE, MES, DIA, COMUNA,
                           FESTIVO, MADRE, NAVIDAD, BRUJITOS, SEMSANTA, 
                           ESCOLAR) %>%
                  summarise(ACCIDENTES = n()) %>%
                  arrange(FECHA) # organizar por fecha

# convertir dia y periodo a enteros
acc_agrupado_2$DIA <- as.integer(acc_agrupado_2$DIA)
acc_agrupado_2$PERIODO <- as.integer(acc_agrupado_2$PERIODO)
```

##### **Elección del modelo de regresión**

##### Modelo lineal grupo 0
```{r lm_grupo0, message=FALSE, warning=FALSE}
## regresion lineal grupo 0

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_0 <- lm(ACCIDENTES ~ FECHA + CLASE + DISENO + DIA_NOMBRE + PERIODO +
                    FESTIVO + MADRE + NAVIDAD + BRUJITOS + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_0, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_0)
```

##### Modelo lineal grupo 1
```{r lm_grupo1, message=FALSE, warning=FALSE}
## regresion lineal grupo 1

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1 <- lm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + DIA + PERIODO +
                    FESTIVO + MADRE + NAVIDAD + BRUJITOS + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_1, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_1)
```

Al verificar los valores P, se opta por retirar la variable *BRUJITOS*.
```{r lm_grupo1_nobruj, message=FALSE, warning=FALSE}
## regresion lineal grupo 1 sin brujitos

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1 <- lm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + DIA + PERIODO +
                    FESTIVO + MADRE + NAVIDAD + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_1, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_1)
```

Como no se observa ningún cambio en el R cuadrado ajustado, se opta por retirar *DIA*. 
```{r lm_grupo1_sinbruj_sindia, message=FALSE, warning=FALSE}
## regresion lineal grupo 1 sin brujitos ni dia

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1 <- lm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO + 
                    FESTIVO + MADRE + NAVIDAD + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_1, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_1)
```

Como no se observa ningún cambio en el R cuadrado ajustado, se opta por retirar *MADRE*. 
```{r lm_grupo1_sinbruj_sindia_sinmad, message=FALSE, warning=FALSE}
## regresion lineal grupo 1 sin brujitos, dia, madre

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1 <- lm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO + FESTIVO +
                    NAVIDAD + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_1, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_1)
```

Como no se observa ningún cambio en el R cuadrado ajustado, se opta por retirar 
*ESCOLAR*. 
```{r lm_grupo1_sinbruj_sindia_sinmad_sinesc, message=FALSE, warning=FALSE}
## regresion lineal grupo 1 sin brujitos, dia, madre, escolar

# crear modelo
modelo_lm_1 <- lm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO + FESTIVO + 
                    NAVIDAD + SEMSANTA,
                  data = acc_agrupado_1, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_1)
```

Dado que al retirar la variable anterior el R cuadrado ajustado bajó 0.0001, por lo cual se dejará el modelo con la variable *ESCOLAR*.
```{r lm_grupo1_final, message=FALSE, warning=FALSE}
## regresion lineal grupo 1

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_1 <- lm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO + FESTIVO + 
                    NAVIDAD + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_1, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_1)
```

##### Modelo lineal grupo 2
```{r lm_grupo2, message=FALSE, warning=FALSE}
## regresion lineal grupo 2

# crear modelo
#acc_year$PERIODO <- as.numeric(acc_year$PERIODO)
modelo_lm_2 <- lm(ACCIDENTES ~ FECHA + DIA_NOMBRE + PERIODO + CLASE + MES + 
                    DIA + COMUNA + FESTIVO + MADRE + NAVIDAD + BRUJITOS + 
                    SEMSANTA + ESCOLAR,
                  data = acc_agrupado_2, 
                  subset = (FECHA <= "2017-12-31"))

# ver resultados del modelo
summary(modelo_lm_2)
```

Agregando la variable de comunas se observa que el modelo es menos significativo que el modelo agrupado 1, por lo que se opta por hacer la validación con el modelo agrupado 1.

##### Calculo de $R^2$ manual de la regresión lineal
```{r lm_r2, message=FALSE, warning=FALSE}
## calcular r2 del modelo lineal

# promedio variable observada de entrenamiento
y0_tr <- mean(acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA <= "2017-12-31"])

# calcular distancia variable observada al promedio 
r0_tr <- acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA <= "2017-12-31"] - y0_tr

# calcular la suma cuadratica total (TSS)
R0_tr<-mean(r0_tr^2)

# hallar variable estimada
y_pred_tr_lm<-predict(modelo_lm_1)

# calcular distancia variable observaa y variable estimada
r_tr_lm <- acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA <= "2017-12-31"] -
           y_pred_tr_lm

# calcular suma cuadratica de la regresion (ESS)
R_tr_lm<-mean(r_tr_lm^2)

# calculo del r2 (r2 = 1 - (ESS/TSS))
R2_lm<-1-R_tr_lm/R0_tr

# ver r2
print(R2_lm)
```

##### Modelo Poisson

Se procede a evaluar el modelo lineal generalizado de una distribución *Poisson* en el grupo 1.
```{r glm_grupo1, message=FALSE, warning=FALSE}
## regresion lineal poisson grupo 1

# crear modelo
modelo_glm <- glm(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO +
                    FESTIVO + NAVIDAD + SEMSANTA + ESCOLAR,
                  data = acc_agrupado_1,
                  subset = (FECHA <= "2017-12-31"),
                  family = "poisson")

# ver resultados del modelo
summary(modelo_glm)
```

##### Cálculo del Pseudo $R^2$ del modelo lineal general de Poisson
```{r pseudor2_glm, message=FALSE, warning=FALSE}
## calcular el pseudo r2 del modelo poisson

# calcular variable estimada
y_pred_tr_glm <- predict(modelo_glm, type = "response")

# calcular diferencia variable observada y variable estimada
r_tr_glm <- acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA <= "2017-12-31"] -
            y_pred_tr_glm

# hallar la proxy de la suma cuadratica de la regresion (ESS)
R_tr_glm <- mean(r_tr_glm^2)

# calcular el pseudo r2 (pseudor2 = 1 - (proxy(ESS)/TSS))
R2_tr_glm <- 1 - R_tr_glm/R0_tr

# ver pseudo r2
print(R2_tr_glm)
```

Este modelo muestra un pseudo-$R^2$ que se usará para hacer las comparaciones entre los modelos.

##### Análisis de predichos versus observados

Se elabora un DataFrame para poder graficar predichos y observados de los modelos.
```{r df_predichos_observados, message=FALSE, warning=FALSE}
## crear dataframe predichos y observados

# crear dataframe
resultados_lm_glm <- data.frame(
  FECHA =   acc_agrupado_1$FECHA[acc_agrupado_1$FECHA <= "2017-12-31"],
  ACCIDENTES = acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA<="2017-12-31"],
  pred_lm = y_pred_tr_lm,
  pred_glm = y_pred_tr_glm,
  res_lm = r_tr_lm,
  res_glm = r_tr_glm)
```

##### Gráfica de predichos y observados
```{r grafica_predichos_observados, message=FALSE, warning=FALSE}
## crear grafica de predichos y observados

# crear grafica
plot_ly (data = resultados_lm_glm,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter",
         mode = "lines",
         name='Real',
         line = list(width = 1, color = 'rgb(205, 12, 24)')) %>%
  add_trace(y= ~pred_lm,
            name = 'Modelo lineal general',
            line = list(width = 1, color = 'rgb(22, 96, 167)')) %>%
  add_trace(y = ~pred_glm,
            name = 'Modelo Poisson',
            line = list(width = 1, color = 'rgb(255, 51, 0)')) %>%
  layout(title = 'Registros DE ACCIDENTES ',
         xaxis = list(title = "Fecha"),
         yaxis = list(title = "ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

##### Comparativo entre modelo lineal y observados
```{r grafica_lm_predichos_observados, message=FALSE, warning=FALSE}
## crear grafica de predichos y observados para el modelo lineal

# crear grafica
plot_ly (data = resultados_lm_glm,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter",
         mode = "lines",
         name = 'Real',
         line = list(width = 1, color = 'rgb(205, 12, 24)')) %>%
  add_trace(y = ~pred_lm,
            name = 'Modelo lineal general',
            line = list(width = 1, color = 'rgb(22, 96, 167)')) %>%
  layout(title = 'Registros de Accidentes',
         xaxis = list(title="Fecha"),
         yaxis = list(title="Accidentes"),
         legend = list(x = 0.75, y = 0.9))
```

##### Comparativo entre modelo Poisson y observados
```{r grafica_glm_predichos_observados, message=FALSE, warning=FALSE}
## crear grafica de predichos y observados para el modelo poisson

# crear grafica
plot_ly (data = resultados_lm_glm,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter",
         mode = "lines",
         name = 'Real',
         line = list(width = 1, color = 'rgb(205, 12, 24)')) %>%
  add_trace(y = ~pred_glm,
            name = 'Modelo Ajustado Poisson',
            line = list(width = 1, color = 'rgb(22, 96, 167)')) %>%
  layout(title = 'Registros de Accidentes',
         xaxis = list(title="Fecha"),
         yaxis = list(title="Accidentes"),
         legend = list(x = 0.75, y = 0.9))
```

Se puede observar que los modelos logran describir las observaciones sin observar ningún comportamiento extraño.

##### Predichos vs observados en el modelo Poisson
```{r grafica_glm_predichos_vs_observados, message=FALSE, warning=FALSE}
## crear grafica de predichos vs observados para el modelo poisson

# crear grafica
plot_ly (data = resultados_lm_glm,
         x = ~ACCIDENTES,
         y = ~pred_lm,
         text = ~FECHA,
         type = "scatter",
         mode = "markers",
         name = 'Modelo lineal general',
         marker = list(size = 3, color = 'rgb(22, 96, 167)')) %>%
  add_trace(y = ~pred_glm,
            text = ~FECHA,
            name = 'Modelo lineal Poisson',
            marker = list(size = 3, color = 'rgb(255, 51, 0)')) %>%
  add_trace(x = c(0:150), y = c(0:150),
            mode = "lines",
            text = rep(NA, 151),
            name = "Identidad") %>%
  layout(title = 'Registros ACCIDENTALIDAD',
         xaxis = list(title = "Observados"),
         yaxis = list(title = "Predichos"),
         legend = list(x = 0.75, y = 0.9))
```

##### Residuales vs observados:
```{r grafica_glm_residuales_vs_observados, message=FALSE, warning=FALSE}
## crear grafica de residuales vs observados para el modelo poisson

# crear grafica
plot_ly (data = resultados_lm_glm,
         x = ~ACCIDENTES,
         y = ~res_lm,
         type = "scatter",
         mode = "markers",
         name = 'Modelo lineal general',
         text = ~FECHA,
         marker = list(size = 3, color = 'rgb(22, 96, 167)')) %>%
  add_trace(y = ~res_glm,
            name = 'Modelo Poisson',
            text = ~FECHA,
            marker = list(size = 3, color = 'rgb(255, 51, 0)')) %>%
  layout(title = 'Registros ACCIDENTES',
         xaxis = list(title="Observados"),
         yaxis = list(title="Residuales"),
         legend = list(x = 0.75, y = 0.9))
```

##### Predicción del 2018

Se calculan las predicciones para el modelo lineal y el modelo Poisson
```{r validacion_lm_glm_2018, message=FALSE, warning=FALSE}
## calcular valores pronosticados para los datos de validacion

# crear subconjunto de los datos de validacion
datos_val <- subset(acc_agrupado_1,
                    subset = (FECHA >= "2018-01-01" & FECHA <= "2018-12-31"))

# calcular media de datos de validacion
yo_vl <- mean(datos_val$ACCIDENTES)

# calcular valores pronosticados modelo lineal
y_pred_vl_lm <- predict(modelo_lm_1, newdata = datos_val)

# calcular valores pronosticados modelo poisson
y_pred_vl_glm <- predict(modelo_glm, type = "response", newdata = datos_val)

# calcular diferencias entre observados y pronosticados en validacion
r_vl_lm <- datos_val$ACCIDENTES - y_pred_vl_lm
r_vl_glm <- datos_val$ACCIDENTES - y_pred_vl_glm

# calcular distancia entre datos observados y su media en la validacion
r0_vl <- datos_val$ACCIDENTES - yo_vl
```

Se calculan los $R^2$ de predicción en la validación
```{r r2_validacion, message=FALSE, warning=FALSE}
## calculo del r2 en los datos de validacion

# calcular suma cuadratica de la regresion para modelo lineal y poisson
R_vl_lm <- mean(r_vl_lm^2)
R_vl_glm <- mean(r_vl_glm^2)

# calcular suma cuadratica total
R0_vl<-mean(r0_vl^2)

# calcular r2 y pseudo r2 en la validacion
R2_vl_lm <- 1-R_vl_lm/R0_vl
R2_vl_glm <- 1-R_vl_glm/R0_vl

# visualizar resultados
print(R2_vl_lm)
print(R2_vl_glm)
```

Se crea una gráfica de los residuales en validación
```{r grafica_residuales_validacion, message=FALSE, warning=FALSE}
## grafica de los residuales de los modelos lineales y poisson 
## para los datos de validacion

# crear dataframe
resultados_lm_glm_val <- data.frame( FECHA = datos_val$FECHA,
                                     ACCIDENTES = datos_val$ACCIDENTES,
                                     pred_lm = y_pred_vl_lm,
                                     pred_glm = y_pred_vl_glm,
                                     res_lm = r_vl_lm,
                                     res_glm = r_vl_glm)

# crear grafica
plot_ly (data = resultados_lm_glm_val,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter",
         mode = "lines",
         name = 'Real',
         line = list(width = 1, color = 'rgb(205, 12, 24)')) %>%
  add_trace(y = ~pred_lm,
            name = 'Modelo lineal general',
            line = list(width = 1, color = 'rgb(22, 96, 167)')) %>%
  add_trace(y = ~pred_glm,
            name = 'Modelo Poisson',
            line = list(width = 1, color = 'rgb(255, 51, 0)')) %>%
  layout(title = 'Registros ACCIDENTES (Validación)',
         xaxis = list(title="FECHA"),
         yaxis = list(title="ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

##### Modelo árbol de decisión para el grupo 1

Para entrenar árboles de decisiones se utilizará el grupo 1 y el paquete *rpart*.

Entrenamiento del árbol
```{r arbol_grupo1, message=FALSE, warning=FALSE}
## ajustar un modelo de arboles de decision para el grupo 1

# cargar paquete
library(rpart)

# crear el modelo
modelo_rpart <- rpart(ACCIDENTES ~ FECHA + CLASE + DIA_NOMBRE + PERIODO + 
                        FESTIVO + NAVIDAD + SEMSANTA + ESCOLAR,
                      data = acc_agrupado_1, 
                      subset = (FECHA <= "2017-12-31"))
```

##### Visualización del resultado del modelo
```{r resultado_arbol, message=FALSE, warning=FALSE}
## visualizar arbol

# imprimir resultados
print(modelo_rpart)
```

Se puede visualizar de una forma más cómoda para el usuario con la función *rpart.plot()* del paquete *rpart.plot*:
```{r resultado_arbol_rpart, message=FALSE, warning=FALSE}
## visualizar arbol

# cargar paquete
library(rpart.plot)

# visualizar resultados
rpart.plot(modelo_rpart, tweak = 1.1)
```

Visualización de la importancia de las variables:
```{r arbol_variables, message=FALSE, warning=FALSE}
## visualizar el impacto de las variables en el modelo

# ver resultados del modelo
summary(modelo_rpart)
```

Se procede con el cálculo de los $R^2$ de predicción y entrenamiento para el árbol:
```{r r2_arbol, message=FALSE, warning=FALSE}
## calcular el pseudo r2 del modelo de arbol para entramiento y validacion

# hallar valores estimados y predichos
y_pred_tr_rpart <- predict(modelo_rpart)
y_pred_vl_rpart <- predict(modelo_rpart,newdata = datos_val)

# calcular diferencia entre variable observada y variable estimada
r_tr_rpart <- acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA <= "2017-12-31"] -
              y_pred_tr_rpart
r_vl_rpart <- datos_val$ACCIDENTES - y_pred_vl_rpart

# calcular la suma cuadratica de la estimacion 
R_tr_rpart <- mean(r_tr_rpart^2)
R_vl_rpart <- mean(r_vl_rpart^2)

# calcular los pseudo r2
R2_tr_rpart <- 1 - R_tr_rpart/R0_tr
R2_vl_rpart <- 1 - R_vl_rpart/R0_vl

# ver resultados
print(R2_tr_rpart)
print(R2_vl_rpart)
```

#### Comparación de todos los modelos

Se crea una nueva tabla que permita comparar los modelos en el entrenamiento:
```{r comparar_modelos_entrenamiento, message=FALSE, warning=FALSE}
## crear dataframe de resultados en entrenamiento

# crear dataframe
comparacion_tr <- data.frame(
  FECHA = acc_agrupado_1$FECHA[acc_agrupado_1$FECHA <= "2017-12-31"],
  ACCIDENTES = acc_agrupado_1$ACCIDENTES[acc_agrupado_1$FECHA <= "2017-12-31"],
  glm = y_pred_tr_glm,
  arbol = y_pred_tr_rpart)
```

Se grafican todas las series en entrenamiento:
```{r grafica_modelos_entrenamiento, message=FALSE, warning=FALSE}
## graficas de los 3 modelos en entrenamiento y datos observados

# graficar
plot_ly (data = comparacion_tr,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter",
         mode = "lines",
         name = 'Real',
         line = list(width = 1, color = 'rgb(205, 12, 24)')) %>%
  add_trace(y = ~glm,
            name = 'Modelo Poisson',
            line = list(width = 1, color = 'rgb(22, 96, 167)')) %>%
  add_trace(y = ~arbol,
            name ='Árbol',
            line = list(width = 1, color = 'rgb(255, 51, 0)')) %>%
  layout(title = 'Registros ACCIDENTES (Entrenamiento)',
         xaxis = list(title = "FECHA"),
         yaxis = list(title = "ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

Se crea una nueva tabla que permita comparar los modelos en la validación:
```{r comparar_modelos_validacion, message=FALSE, warning=FALSE}
## crear dataframe de resultados en validacion

# crear dataframe
comparacion_vl <- data.frame(FECHA = datos_val$FECHA,
                             ACCIDENTES = datos_val$ACCIDENTES,
                             glm = y_pred_vl_glm,
                             arbol = y_pred_vl_rpart)
```

Se grafican todas las series en validación:
```{r grafica_modelos_validacion, message=FALSE, warning=FALSE}
## graficas de los 3 modelos en entrenamiento y datos observados

# graficar
plot_ly (data = comparacion_vl,
         x = ~FECHA,
         y = ~ACCIDENTES,
         type = "scatter",
         mode = "lines",
         name = 'Real',
         line = list(width = 1, color = 'rgb(205, 12, 24)')) %>%
  add_trace(y= ~glm,
            name = 'Modelo Poisson',
            line = list(width = 1, color = 'rgb(22, 96, 167)')) %>%
  add_trace(y = ~arbol,
            name = 'Árbol',
            line = list(width = 1, color = 'rgb(255, 51, 0)')) %>%
  layout(title = 'Registros ACCIDENTES (Validación)',
         xaxis = list(title = "FECHA"),
         yaxis = list(title = "ACCIDENTES"),
         legend = list(x = 0.75, y = 0.9))
```

[Regresar](#tabla-de-contenido)

### **2.5. Evaluación del modelo**

Se crea una tabla con la información de los $R^2$ y los errores cuadráticos medios (*MSE*) para elegir el modelo que mejor ajusta el comportamiento de los datos.
```{r tabla_r2_modelos, message=FALSE, warning=FALSE}
## crear tabla informativa de los r2 para los 3 modelos

# r2 de entrenamiento
Entrenamiento <- c(R2_lm, R2_tr_glm, R2_tr_rpart)

# r2 de validacion
Validacion <- c(R2_vl_lm, R2_vl_glm, R2_vl_rpart)

# error cuadratico medio
MSE_acc <- c(R_vl_lm, R_vl_glm, R_vl_rpart)

# vector de nombres
nombres <- c("lm", "glm", "árbol")

# crear dataframe
ResultadosR2 <- data.frame(Entrenamiento = Entrenamiento,
                           Validacion = Validacion,
                           MSE = MSE_acc)

# cambiar nombre de filas
rownames(ResultadosR2) <- nombres

# ver resultados
ResultadosR2
```

El criterio de selección será el Error Cuadrático Medio y el modelo que tiene el mínimo es:
```{r echo=FALSE, message=FALSE, warning=FALSE}
print(ResultadosR2[which(ResultadosR2$MSE == min(ResultadosR2$MSE)),])
```

A partir de estas evidencias se escoge el modelo lineal general con distribución de Poisson como el modelo más conveniente para hacer la predicción.

[Regresar](#tabla-de-contenido)

### **2.6. Implementación**
 
Se prepara el modelo para hacer la predicción del año 2019, se importa el correspondiente archivo de entrada para realizar la predicción.

```{r lectura_matriz_2019, message=FALSE, warning=FALSE}
## lectura de los datos a utilizar para pronosticar 2019

# lectura
matriz_2019 <- fread("files/matriz-2019-pronostico.csv",
                     sep = ";",
                     colClasses = "character")

# organizar fecha y periodo
matriz_2019$FECHA <- as.Date(matriz_2019$FECHA)
matriz_2019$PERIODO <- as.numeric(matriz_2019$PERIODO)
```

Se crea el nuevo vector de predicciones
```{r prediccion_2019, message=FALSE, warning=FALSE}
## calcular la prediccion para el 2019

# calcular prediccion
ACCIDENTES_PRED <- predict(modelo_glm, newdata = matriz_2019, type = "response")
```

Se guarda junto el conjunto de datos nuevo para ser visualizado en la aplicación
```{r guardar_prediccion_2019, message=FALSE, warning=FALSE}
## guardar nuevas predicciones

# organizar nuevas predicciones en matriz_2019
ACCIDENTES_PRED <- matriz_2019 %>% 
                   mutate(ACCIDENTES = round(predict(modelo_glm, 
                                                     newdata = matriz_2019, 
                                                     type = "response"),
                                             0)
                          )

# guardar nuevo conjunto de datos
fwrite(ACCIDENTES_PRED, "files/matriz-2019-pronosticada.csv", sep = ";")
```

El pronóstico de los datos es utilizado para crear una aplicación en línea, totalmente abierta al público y puede consultarse en [este enlace](https://juapatral.shinyapps.io/MoviliApp/)).

[Regresar](#tabla-de-contenido)

## **3. Conclusiones**

En este trabajo se analizó un conjunto de datos relacionados con accidentes de tráfico, donde se busca un modelo que se acerque a la condicción actual del fenómeno que presentan los datos reales. Las técnicas de análisis descriptivo de grandes cantidades de datos a partir de la analítica permitieron encontrar tendencias y patrones ocultos de los datos. La comparación de estos patrones con los resultados del modelo de accidentalidad vial planteado ayuda a la validación del modelo dado que fundamenta la selección de las variables que se enfatizan como las más incidentes a partir de la visualización de su ocurrencia en los registros actuales.

Se evaluaron tres tipos de modelos: la regresión lineal multivariada, regresión lineal generalizada con distribuación Poisson y árbol de decisiones. Se encontró que los factores que más influencian los accidentes de tránsito corresponden a la clase de accidente, día del accidente y un fuerte impacto en determinados días especiales a lo largo del año, como los días festivos, las vacaciones colectivas, entre otros.

El modelo de regresión generalizado con regresión Poisson mostró ser efectivo en este caso porque el fenómeno se define como un conteo influenciado por un conjunto de variables predictoras, obteniendo un $R^2$ más cercano a uno y un Error Cuadrático Medio menor, después de eliminar variables que no son estadísticamente significativas para la muestra examinada.

En la  verificación del modelo se evidencian ciertos comportamientos en la predicción del 2019 como en los datos reales, algunos de éstos fueron:

+ Los accidentes son más propensos a ocurrir en forma de choque, esto contextualizandolo por ser un entorno urbano.

+ El día más traumático en movilidad es el viernes. En efecto, es un día de mucho tráfico para una ciudad como Medellín ya que se finaliza la jornada laboral, semana de trabajo y la gente opta por salir a divertirse o llegar rápido a sus casas, por lo que el contexto hace que se generen más siniestros de lo normal.

+ Los días más tranquilo son el domingo, por ser día de descanso para estudiantes y trabajadores, y el lunes, que está influenciado por los días festivos que, en la mayoría de los casos, son lunes. 

Para el uso de técnicas de analítica predictiva, tuvimos en cuenta que la calidad del resultado depende de la calidad de los datos y de cómo estos se hayan recogido, organizado y depurado. Esto es esencial para la construcción de un modelo hipotético acerca de cómo se comporta el fenómeno a analizar y, con ello, de cómo podrá comportarse en el futuro.

[Regresar](#tabla-de-contenido)

## **4. Bibliografía**

+ Alcaldia de Medellín. (2013) *Plan de movilidad segura de Medellín 2014-2020.*

+ Cabrera G., López A. (2017) *Epidemiología de incidentes viales en Medellín-Colombia, 2010-2015.  Revista Facultad Nacional de Salud Pública.*

+ Friedman, J., Hastie, T., & Tibshirani, R. (2001). *The elements of statistical learning (Vol. 1, No. 10). New York: Springer series in statistics.*

+ Hothorn, T., & Everitt, B. S. (2014). *A handbook of statistical analyses using R. Chapman and Hall/CRC.*

+ James, G., Witten, D., Hastie, T., & Tibshirani, R. (2013). *An introduction to statistical learning (Vol. 112, p. 18). New York: springer.*

+ Jaramillo C., Montoya S. (2017) *Movilidad Segura en Medellín, Observatorio de Políticas Públicas del Consejo de Medellin.*

+ McCullagh, P. (2019). *Generalized linear models. Routledge.*

+ Montgomery, D. C., & Runger, G. C. (2007). *Applied statistics and probability for engineers, (With CD). John Wiley & Sons.*

+ Ospina J. (2019) *Introducción a la analítica predictiva, Vehículos registrados en el RUNT. Material de clase especialización en Analítica Unal.*

---

**R Markdown**

+ [Infografía de *Rmarkdown*](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)

+ [API de *Rmarkdown*](https://bookdown.org/yihui/rmarkdown/)

---

**Plotly**

+ [API de *Plotly*](https://plot.ly/r/reference/)

+ [API de *Plotly*, parte 2](https://plot.ly/r/reference/#Layout_and_layout_style_objects)

+ [Gráfico de área en *Plotly*](https://plot.ly/r/filled-area-plots/)

+ [Aplicar color a barra vertical en *Plotly*](https://stackoverflow.com/questions/33891362/r-shiny-background-of-sidebar-panel)

+ [Ajustar tamaño en *Plotly*](https://plot.ly/r/setting-graph-size/)

+ [Descripción emergente en *Plotly*](https://plot.ly/r/hover-text-and-formatting/)

---

**LeafLet y archivos espaciales**

+ [Introducción a los archivos espaciales en *R*](https://datacarpentry.org/r-raster-vector-geospatial/06-vector-open-shapefile-in-r/)

+ [Lectura de archivos espaciales usando *ST* en *R*](https://r-spatial.github.io/sf/reference/st_read.html)

+ [API de *LeafLet* en *R*](https://rstudio.github.io/leaflet/map_widget.html)

+ [Etiquetas y descripción emergente en *LeafLet* para *R*](https://stackoverflow.com/questions/48147282/how-to-add-labels-on-top-of-polygons-in-leaflet)

+ [Opciones de resaltar en *LeafLet* para *R*](https://stackoverflow.com/questions/46209309/r-leaflet-highlight-options)

---

**Shiny**

+ [API de *Shiny*](http://shiny.rstudio.com/articles/basics.html)

+ [Incrustar videos en *Shiny*](https://stackoverflow.com/questions/43740470/embed-instagram-youtube-into-shiny-r-app)

+ [Rango de fechas en *Shiny*](https://shiny.rstudio.com/gallery/date-and-date-range.html)

+ [Pestañas en *Shiny*](https://shiny.rstudio.com/articles/tabsets.html)

+ [Incrustar HTML y Markdown en *Shiny*](http://shiny.rstudio.com/gallery/including-html-text-and-markdown-files.html)

+ [Lista desplegable en Shiny](https://shiny.rstudio.com/reference/shiny/latest/selectInput.html)

+ [*Plotly* en *Shiny*](https://stackoverflow.com/questions/41255810/r-shinyapp-not-showing-plot-ly-in-browser-but-show-only-graph-in-viewer-pane)

+ [Barra deslizable y rango en *Shiny*](http://shiny.rstudio.com/gallery/slider-bar-and-slider-range.html)

+ [Embeber imágen en *Shiny*](https://stackoverflow.com/questions/21996887/embedding-image-in-shiny-app)

+ [Ajustar posición en *Shiny*](https://stackoverflow.com/questions/42913364/center-plotly-plot-in-r-shiny?rq=1)

+ [Fecha y rango de fechas en *Shiny*](https://shiny.rstudio.com/gallery/date-and-date-range.html)

+ [*LeafLet* en *Shiny*](https://spatialanalysis.github.io/workshop-notes/interactive-maps-with-shiny.html)

+ [Lista de pestañas en *Shiny*](https://shiny.rstudio.com/reference/shiny/1.0.2/navlistPanel.html)

+ [Error en pestañas en *Shiny* (comentario de Natalie K)](https://groups.google.com/forum/#!topic/shiny-discuss/CzO8wb15RPI)

---

**Otras**

+ [Paleta de colores para mapas](http://colorbrewer2.org/#type=diverging&scheme=RdYlBu&n=7)

+ [Redes neuronales con *neuralnet*](https://www.datacamp.com/community/tutorials/neural-network-models-r)

+ [Agrupar por vector de caracteres en *dplyr*](https://stackoverflow.com/questions/36660152/concatenating-words-without-quotes-in-r-for-groupby-in-dplyr)

+ [Reordenar factores en *R*](https://www.r-bloggers.com/reorder-factor-levels/)

+ [Ejemplo de una regresion Poisson en *R*](https://www.dataquest.io/blog/tutorial-poisson-regression-in-r/)

---

[Regresar](#tabla-de-contenido)
